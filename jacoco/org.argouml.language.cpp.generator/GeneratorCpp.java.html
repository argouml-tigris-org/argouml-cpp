<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeneratorCpp.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">argo_cpp</a> &gt; <a href="index.source.html" class="el_package">org.argouml.language.cpp.generator</a> &gt; <span class="el_source">GeneratorCpp.java</span></div><h1>GeneratorCpp.java</h1><pre class="source lang-java linenums">/* $Id$
 *****************************************************************************
 * Copyright (c) 2009-2013 Contributors - see below
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Luis Sergio Oliveira (euluis)
 *****************************************************************************
 *
 * Some portions of this file was previously release using the BSD License:
 */

// Copyright (c) 1996-2009 The Regents of the University of California. All
// Rights Reserved. Permission to use, copy, modify, and distribute this
// software and its documentation without fee, and without a written
// agreement is hereby granted, provided that the above copyright notice
// and this paragraph appear in all copies.  This software program and
// documentation are copyrighted by The Regents of the University of
// California. The software program and documentation are supplied &quot;AS
// IS&quot;, without any accompanying services from The Regents. The Regents
// does not warrant that the operation of the program will be
// uninterrupted or error-free. The end-user understands that the program
// was developed for research purposes and is advised not to rely
// exclusively on the program for any reason.  IN NO EVENT SHALL THE
// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF
// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

package org.argouml.language.cpp.generator;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.text.DateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.GregorianCalendar;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.UUID;
import java.util.Vector;
import java.util.logging.Logger;

import org.argouml.configuration.Configuration;
import org.argouml.configuration.ConfigurationKey;
import static org.argouml.language.cpp.profile.ProfileCpp.*;

import static org.argouml.model.Model.*;
import org.argouml.uml.DocumentationManager;
import org.argouml.uml.UUIDHelper;
import org.argouml.uml.generator.CodeGenerator;
import org.argouml.uml.generator.SourceUnit;

/**
 * Class to generate C++ source code.
 *
 * WARNING: Don't know if this is a threat (and I think it's not), but this
 * class is NOT THREAD SAFE. DO NOT CALL METHODS FROM DIFFERENT THREADS.
 * At the moment, it works, but this is just in case someone in the future
 * tries to generate 1265 files in parallel and guesses why it doesn't work :-)
 */
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">public class GeneratorCpp implements CodeGenerator {</span>

    /**
     * The logger.
     */
<span class="fc" id="L86">    private static final Logger LOG = Logger.getLogger(</span>
<span class="fc" id="L87">            GeneratorCpp.class.getName());</span>
    
    static final String LANGUAGE_NAME = &quot;cpp&quot;;

    // Customizable variables

<span class="fc" id="L93">    private boolean verboseDocs = false;</span>
<span class="fc" id="L94">    private boolean lfBeforeCurly = false;</span>
<span class="fc" id="L95">    private String indent = &quot;    &quot;; // customizable (non final) indent</span>
    
<span class="fc" id="L97">    private boolean hdrGuardUpperCase = false;</span>
<span class="fc" id="L98">    private boolean hdrGuardGUID = false;</span>
    
    // Configuration keys for the above configurable variables
<span class="fc" id="L101">    private static final ConfigurationKey KEY_CPP_INDENT =</span>
<span class="fc" id="L102">        Configuration.makeKey(LANGUAGE_NAME, &quot;indent&quot;);</span>
<span class="fc" id="L103">    private static final ConfigurationKey KEY_CPP_LF_BEFORE_CURLY =</span>
<span class="fc" id="L104">        Configuration.makeKey(LANGUAGE_NAME, &quot;lf-before-curly&quot;);</span>
<span class="fc" id="L105">    private static final ConfigurationKey KEY_CPP_VERBOSE_COMM =</span>
<span class="fc" id="L106">        Configuration.makeKey(LANGUAGE_NAME, &quot;verbose-comments&quot;);</span>
<span class="fc" id="L107">    private static final ConfigurationKey KEY_CPP_SECT =</span>
<span class="fc" id="L108">        Configuration.makeKey(LANGUAGE_NAME, &quot;sections&quot;);</span>
<span class="fc" id="L109">    private static final ConfigurationKey KEY_CPP_HEADER_GUARD_UPPERCASE =</span>
<span class="fc" id="L110">        Configuration.makeKey(LANGUAGE_NAME, &quot;header-guard-case&quot;);</span>
<span class="fc" id="L111">    private static final ConfigurationKey KEY_CPP_HEADER_GUARD_GUID =</span>
<span class="fc" id="L112">        Configuration.makeKey(LANGUAGE_NAME, &quot;header-guard-guid&quot;);</span>
<span class="fc" id="L113">    private static final ConfigurationKey KEY_CPP_DEFAULT_INLINE =</span>
<span class="fc" id="L114">        Configuration.makeKey(LANGUAGE_NAME, &quot;default-inline&quot;);</span>

    private static Section sect;

    /**
     * Store actual namespace, to avoid unneeded curly braces.
     *
     * @author Achim Spangler
     * @since 2002-12-07
     */
    private Object actualNamespace;

    /** Current classifier, for which the code is being generated.
     */
<span class="fc" id="L128">    private Object currClass = null;</span>

    /**
     * Set of the local files to include with #include &quot;file.h&quot;
     * Automatically generated from classifier dependencies.
     */
<span class="fc" id="L134">    private Set localInc = new TreeSet();</span>

    /**
     * Set of the external files to include with #include &lt;file.h&gt;
     * Automatically generated from classifier dependencies.
     */
<span class="fc" id="L140">    private Set extInc = new TreeSet();</span>

    /**
     * Set of the system files to include, like #include &lt;vector&gt;
     * Automatically generated.
     */
<span class="fc" id="L146">    private Set systemInc = new TreeSet();</span>
 
    /** Set of classifier that needs to be defined (i.e. #included)
     */
<span class="fc" id="L150">    private Set includeCls = new LinkedHashSet();</span>

    /** Set of classifier that only needs to be predeclared
     */
<span class="fc" id="L154">    private Set predeclCls = new LinkedHashSet();</span>

    /**
     * System newline separator.
     */
<span class="fc" id="L159">    private static final String LINE_SEPARATOR =</span>
<span class="fc" id="L160">        System.getProperty(&quot;line.separator&quot;);</span>

    /**
     * C++ doesn't place visibility information for each class member
     * --&gt; sort items during generation and store visibility state
     * of lastly generated member in central class variable, so that
     * the appropriate lines: &quot;public:&quot;, &quot;protected:&quot;, &quot;private:&quot;
     * can be created.
     *
     * @author Achim Spangler
     * @since 2002-11-28
     */
    private static final int PUBLIC_PART = 0;
    private static final int PROTECTED_PART = 1;
    private static final int PRIVATE_PART = 2;

<span class="fc" id="L176">    private static final int[] ALL_PARTS = {</span>
        PUBLIC_PART,
        PROTECTED_PART,
        PRIVATE_PART,
    };

<span class="fc" id="L182">    private static final String[] PART_NAME = {</span>
        &quot;public&quot;, &quot;protected&quot;, &quot;private&quot;
    };

    /**
     * C++ uses two files for each class: header (.h) with class definition
     * and source (.cpp) with methods implementation
     * --&gt; two generation passes are needed.
     *
     * @author Achim Spangler
     * @since 2002-11-28
     */
    private static final int NONE_PASS = 1;
    private static final int HEADER_PASS = 2;
    private static final int SOURCE_PASS = 3;
<span class="fc" id="L197">    private static int generatorPass = NONE_PASS;</span>

    /**
     * use Tag generation for generation of: doccomment, simple tags of
     * tags which are not used for document or simple tags for all.
     *
     * @author Achim Spangler
     * @since 2002-12-05
     */
    private static final int DOC_COMMENT_TAGS = 1;
    private static final int ALL_BUT_DOC_TAGS = 2;
    private static final int ALL_TAGS = 3;

    /**
     * C++ developers need to specify for parameters whether they are
     * pointers or references (especially for class-types)
     * -&gt; a general check function must get the searched tag.
     *
     * @author Achim Spangler
     * @since 2002-12-06
     */
    private static final int NORMAL_MOD = 0;
    private static final int REFERENCE_MOD = 1;
    private static final int POINTER_MOD = 2;
    private static final int CONST_MOD = 3;

    private static GeneratorCpp singleton;

    /**
     * Prefix for names in the std namespace. Defaults to &quot;std::&quot;,
     * but could be &quot;&quot; if a &quot;using namsepace std;&quot; directive is used.  
     */
<span class="fc" id="L229">    private String stdPrefix = &quot;std::&quot;;</span>
    
    /**
     * Get the instance of the singleton for the C++ generator.
     *
     * @return the singleton of the generator.
     */
    public static synchronized GeneratorCpp getInstance() {
<span class="fc bfc" id="L237" title="All 2 branches covered.">        if (singleton != null)</span>
<span class="fc" id="L238">            return singleton;</span>
<span class="fc" id="L239">        return new GeneratorCpp(); // the constructor will set singleton</span>
    }

    /**
     * Constructor.
     */
<span class="fc" id="L245">    protected GeneratorCpp() {</span>
<span class="fc" id="L246">        singleton = this;</span>
<span class="fc" id="L247">        loadConfig();</span>
<span class="fc" id="L248">    }</span>

    /** Reset the generator in the initial state before
     * starting to generate code.
     */
    protected void cleanupGenerator() {
        // clears collections of dependencies
<span class="fc" id="L255">        localInc.clear();</span>
<span class="fc" id="L256">        extInc.clear();</span>
<span class="fc" id="L257">        systemInc.clear();</span>
<span class="fc" id="L258">        includeCls.clear();</span>
<span class="fc" id="L259">        predeclCls.clear();</span>
        // set currClass to null, so if it's used when it shouldn't
        // it will raise a NullPointerException
<span class="fc" id="L262">        currClass = null;</span>
<span class="fc" id="L263">        actualNamespace = null;</span>
<span class="fc" id="L264">    }</span>

    /** Set up the generator in order to generate the code
     * for 'cls'.
     * @param cls The classifier to generate the code for
     */
    protected void setupGenerator(Object cls) {
<span class="fc" id="L271">        cleanupGenerator();</span>
<span class="fc" id="L272">        currClass = cls;</span>
<span class="fc" id="L273">    }</span>

    /** Internal helper that generates the file content (.cpp or .h)
     * and returns it as a String, without actually creating a file.
     */
    private String generateFileAsString(Object o, String pathname) {
<span class="fc" id="L279">        setupGenerator(o);</span>
<span class="pc bpc" id="L280" title="1 of 4 branches missed.">        if (generatorPass == SOURCE_PASS  &amp;&amp; getFacade().isAInterface(o))</span>
<span class="nc" id="L281">            return &quot;&quot;; // don't generate the .cpp, it's useless.</span>

<span class="fc" id="L283">        String headerTop = generateHeaderTop(pathname);</span>
<span class="fc" id="L284">        String header = generateHeader(o);</span>
        // This can only be a classifier, right? - tfm
<span class="fc" id="L286">        String src = generateClassifier(o);</span>
        
<span class="fc" id="L288">        String inlinedMethods = null;</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">        if (generatorPass == HEADER_PASS) {</span>
<span class="fc" id="L290">            inlinedMethods = generateInlinedMethodsOutsideClass(o);</span>
        }
        
<span class="fc" id="L293">        String footer = generateFooter();</span>
        // generate #includes and predeclarations
        // this must be *after* generate()
<span class="fc" id="L296">        StringBuffer incl = new StringBuffer();</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">        if (generatorPass == SOURCE_PASS) {</span>
<span class="fc" id="L298">            localInc.add(getFacade().getName(o) + &quot;.h&quot;);</span>
        }
<span class="fc" id="L300">        generateIncludes(incl);</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">        if (generatorPass == HEADER_PASS) {</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">            if (incl.length() &gt; 0) incl.append(LINE_SEPARATOR);</span>
<span class="fc" id="L303">            generatePredeclare(incl);</span>
        }
        // paste all the pieces in the final result
<span class="fc" id="L306">        StringBuffer result = new StringBuffer();</span>
<span class="fc" id="L307">        String guard = new String();</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">        if (generatorPass == HEADER_PASS) {</span>
<span class="fc" id="L309">            String name = getFacade().getName(o);</span>
<span class="fc" id="L310">            String guardPack =</span>
<span class="fc" id="L311">                generateRelativePackage(o, null, &quot;_&quot;).substring(1);</span>
<span class="fc" id="L312">            guard = name + getFileExtension().replace('.', '_');</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">            if (guardPack.length() &gt; 0) {</span>
<span class="fc" id="L314">                guard = guardPack + &quot;_&quot; + guard;</span>
            }
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">            if (hdrGuardGUID) {</span>
<span class="nc" id="L317">                guard = guard + &quot;_&quot; </span>
<span class="nc" id="L318">                    + UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;_&quot;);</span>
            }
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">            if (hdrGuardUpperCase) {</span>
<span class="nc" id="L321">                guard = guard.toUpperCase();</span>
            }
            
<span class="fc" id="L324">            result.append(&quot;#ifndef &quot; + guard + LINE_SEPARATOR </span>
                      + &quot;#define &quot; + guard 
                      + LINE_SEPARATOR + LINE_SEPARATOR);
        }
<span class="fc" id="L328">        result.append(headerTop);</span>
<span class="fc" id="L329">        result.append(incl.toString());</span>
<span class="fc" id="L330">        result.append(header);</span>
<span class="fc" id="L331">        result.append(src);</span>
        
<span class="fc bfc" id="L333" title="All 4 branches covered.">        if (generatorPass == HEADER_PASS &amp;&amp; inlinedMethods != null) {</span>
<span class="fc" id="L334">            result.append(inlinedMethods);</span>
        }
        
<span class="fc" id="L337">        result.append(footer);</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">        if (generatorPass == HEADER_PASS) {</span>
<span class="fc" id="L339">            result.append(LINE_SEPARATOR);</span>
<span class="fc" id="L340">            result.append(&quot;#endif&quot; + &quot; // &quot; + guard);</span>
<span class="fc" id="L341">            result.append(LINE_SEPARATOR);</span>
        }
<span class="fc" id="L343">        return result.toString();</span>
    }

    /**
     * Generate the source code (.cpp) for the given object
     * @param o the object to be generated
     * @return the generated code as a string
     */
    String generateCpp(Object o) {
<span class="fc" id="L352">        generatorPass = SOURCE_PASS;</span>
<span class="fc" id="L353">        String name =</span>
<span class="fc" id="L354">            generateRelativePackage(o, null, &quot;/&quot;).substring(1);</span>
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">        if (name.length() &gt; 0) name += &quot;/&quot;;</span>
<span class="fc" id="L356">        name += getFacade().getName(o) + &quot;.cpp&quot;;</span>
<span class="fc" id="L357">        String ret = generateFileAsString(o, name);</span>
<span class="fc" id="L358">        cleanupGenerator();</span>
<span class="fc" id="L359">        generatorPass = NONE_PASS;</span>
<span class="fc" id="L360">        return ret;</span>
    }

    /**
     * Generate the header code (.h) for the given object
     * @param o the object to be generated
     * @return the generated header as a string
     */
    String generateH(Object o) {
<span class="fc" id="L369">        generatorPass = HEADER_PASS;</span>
<span class="fc" id="L370">        String name =</span>
<span class="fc" id="L371">            generateRelativePackage(o, null, &quot;/&quot;).substring(1);</span>
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">        if (name.length() &gt; 0) name += &quot;/&quot;;</span>
<span class="fc" id="L373">        name += getFacade().getName(o) + &quot;.h&quot;;</span>
<span class="fc" id="L374">        String ret = generateFileAsString(o, name);</span>
<span class="fc" id="L375">        cleanupGenerator();</span>
<span class="fc" id="L376">        generatorPass = NONE_PASS;</span>
<span class="fc" id="L377">        return ret;</span>
    }

    /**
     * Generate the package name for the specified object,
     * relative to the specified package. Use sep as the
     * package separator. 
     * @param cls Object to generate the path for
     * @param pack Generate path relative to this package
     * @param sep package separator
     * @return path relative to pack, if pack is a parent of
     *         cls, else relative to the project root. If the
     *         path is relative to the project root, it's prefixed
     *         with sep.
     */
    private String generateRelativePackage(Object cls, Object pack,
            String sep) {
<span class="fc" id="L394">        StringBuffer packagePath = new StringBuffer();</span>
        // avoid model being used as a package name
<span class="fc" id="L396">        Object parent = getFacade().getNamespace(cls);</span>

<span class="fc bfc" id="L398" title="All 4 branches covered.">        while (parent != null &amp;&amp; parent != pack) {</span>
            // ommit root package name; it's the model's root
<span class="fc" id="L400">            Object grandParent = getFacade().getNamespace(parent); </span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">            if (grandParent != null) {</span>
<span class="fc" id="L402">                String name = getFacade().getName(parent);</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">                if (packagePath.length() &gt; 0) {</span>
<span class="nc" id="L404">                    packagePath.insert(0, sep);</span>
                }
<span class="fc" id="L406">                packagePath.insert(0, name);</span>
            }
<span class="fc" id="L408">            parent = grandParent;</span>
<span class="fc" id="L409">        }</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">        if (parent == null) { // relative to root, prefix with sep</span>
<span class="fc" id="L411">            packagePath.insert(0, sep);</span>
        }
<span class="fc" id="L413">        return packagePath.toString();</span>
    }

    /** 2002-11-28 Achim Spangler
     * @return file extension for actual generation pass
     */
    private String getFileExtension() {
<span class="fc bfc" id="L420" title="All 2 branches covered.">        if (generatorPass == HEADER_PASS) return &quot;.h&quot;;</span>
<span class="fc" id="L421">        return &quot;.cpp&quot;;</span>
    }

    /**
     * Generates the relative path for the specified classifier.
     * @param cls The classifier. 
     * @return Returns relative path of cls (without filename).
     */
    private String generatePath(Object cls) {
<span class="nc" id="L430">        String packagePath =</span>
<span class="nc" id="L431">            generateRelativePackage(cls, null, CodeGenerator.FILE_SEPARATOR);</span>
<span class="nc" id="L432">        packagePath = packagePath.substring(1);</span>
<span class="nc" id="L433">        return packagePath;</span>
    }

    /**
     * create the needed directories for the derived appropriate pathname
     * @return Returns the filename with full path of cls.
     */
    private String createDirectoriesPathname(Object cls, String path) {
<span class="fc" id="L441">        String name = getFacade().getName(cls);</span>
<span class="pc bpc" id="L442" title="2 of 4 branches missed.">        if (name == null || name.length() == 0) {</span>
<span class="nc" id="L443">            return &quot;&quot;;</span>
        }

<span class="pc bpc" id="L446" title="1 of 2 branches missed.">        if (!path.endsWith (CodeGenerator.FILE_SEPARATOR)) {</span>
<span class="fc" id="L447">            path += CodeGenerator.FILE_SEPARATOR;</span>
        }

<span class="fc" id="L450">        String packagePath = generateRelativePackage(cls, null, &quot;.&quot;);</span>
<span class="fc" id="L451">        packagePath = packagePath.substring(1);</span>
<span class="fc" id="L452">        String filename = name + getFileExtension();</span>

<span class="fc" id="L454">        int lastIndex = -1;</span>
        do {
<span class="fc" id="L456">            File f = new File (path);</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">            if (!f.isDirectory()) {</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">                if (!f.mkdir()) {</span>
<span class="nc" id="L459">                    LOG.severe(&quot; could not make directory &quot; + path);</span>
<span class="nc" id="L460">                    return null;</span>
                }
            }

<span class="fc bfc" id="L464" title="All 2 branches covered.">            if (lastIndex == packagePath.length()) {</span>
<span class="fc" id="L465">                break;</span>
            }

<span class="fc" id="L468">            int index = packagePath.indexOf (&quot;.&quot;, lastIndex + 1);</span>
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">            if (index == -1) {</span>
<span class="fc" id="L470">                index = packagePath.length();</span>
            }

<span class="fc" id="L473">            path += packagePath.substring(lastIndex + 1, index)</span>
                + CodeGenerator.FILE_SEPARATOR;
<span class="fc" id="L475">            lastIndex = index;</span>
<span class="fc" id="L476">        } while (true);</span>

<span class="fc" id="L478">        String pathname = path + filename;</span>
        //LOG.info(&quot;-----&quot; + pathname + &quot;-----&quot;);
<span class="fc" id="L480">        return pathname;</span>
    }

    /* Returns true if the given object is a class (or interface) within
     * another class (not within a package).
     */
    private static boolean isAInnerClass(Object cls) {
<span class="fc" id="L487">        Object parent = getFacade().getNamespace(cls);</span>
<span class="pc bpc" id="L488" title="2 of 4 branches missed.">        return parent != null &amp;&amp; !getFacade().isAPackage(parent);</span>
    }

    /** 2002-12-07 Achim Spangler
     * @return date
     */
    private String getDate() {
<span class="nc" id="L495">        GregorianCalendar cal = new GregorianCalendar();</span>
        DateFormat df;
<span class="nc" id="L497">        df = DateFormat.getDateInstance(DateFormat.DEFAULT);</span>
<span class="nc" id="L498">        return df.format(cal.getTime());</span>
    }

    /** 2002-12-07 Achim Spangler
     * @return year
     */
    private String getYear() {
<span class="nc" id="L505">        GregorianCalendar cal = new GregorianCalendar();</span>
<span class="nc" id="L506">        return Integer.toString(cal.get(Calendar.YEAR));</span>
    }

    /** 2002-12-07 Achim Spangler
     * write template content on top of file
     */
    private void writeTemplate(Object cls, String path, BufferedWriter fos) {
<span class="fc" id="L513">        String templatePathName = path + &quot;/templates/&quot;;</span>
<span class="fc" id="L514">        String fileName = getFacade().getName(cls);</span>
<span class="fc" id="L515">        String tagTemplatePathName = getFacade().getTaggedValueValue(</span>
                cls, TV_NAME_TEMPLATE_PATH);
<span class="fc" id="L517">        String authorTag = getFacade().getTaggedValueValue(cls, </span>
                TV_NAME_AUTHOR);
<span class="fc" id="L519">        String emailTag = getFacade().getTaggedValueValue(cls, </span>
                TV_NAME_EMAIL);
<span class="pc bpc" id="L521" title="2 of 4 branches missed.">        if (tagTemplatePathName != null &amp;&amp; tagTemplatePathName.length() &gt; 0)</span>
<span class="nc" id="L522">            templatePathName = tagTemplatePathName;</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">        if (generatorPass == HEADER_PASS) {</span>
<span class="fc" id="L524">            templatePathName = templatePathName + &quot;header_template&quot;;</span>
<span class="fc" id="L525">            fileName = fileName + &quot;.h&quot;;</span>
        }
        else {
<span class="fc" id="L528">            templatePathName = templatePathName + &quot;cpp_template&quot;;</span>
<span class="fc" id="L529">            fileName = fileName + &quot;.cpp&quot;;</span>
        }
        
<span class="fc" id="L532">        File templateFile = new File(templatePathName);</span>
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">        if (templateFile.exists()) {</span>
<span class="nc" id="L534">            boolean eof = false;</span>
<span class="nc" id="L535">            BufferedReader templateFileReader = null;</span>
            try {
                // TODO: This is using the default platform character encoding
                // specifying an encoding will produce more predictable results
<span class="nc" id="L539">                templateFileReader =</span>
                    new BufferedReader(new FileReader(
<span class="nc" id="L541">                        templateFile.getAbsolutePath()));</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">                while (!eof) {</span>
<span class="nc" id="L543">                    String lineStr = templateFileReader.readLine();</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">                    if (lineStr == null) {</span>
<span class="nc" id="L545">                        eof = true;</span>
                    } else {
<span class="nc" id="L547">                        StringBuffer line = new StringBuffer(lineStr);</span>
<span class="nc" id="L548">                        replaceToken(line, &quot;|FILENAME|&quot;, fileName);</span>
<span class="nc" id="L549">                        replaceToken(line, &quot;|DATE|&quot;, getDate());</span>
<span class="nc" id="L550">                        replaceToken(line, &quot;|YEAR|&quot;, getYear());</span>
<span class="nc" id="L551">                        replaceToken(line, &quot;|AUTHOR|&quot;, authorTag);</span>
<span class="nc" id="L552">                        replaceToken(line, &quot;|EMAIL|&quot;, emailTag);</span>

<span class="nc" id="L554">                        fos.write(line + LINE_SEPARATOR);</span>
                    }
<span class="nc" id="L556">                }</span>
<span class="nc" id="L557">                templateFileReader.close();</span>
            }
<span class="nc" id="L559">            catch (IOException exp) { }</span>
            finally {
                try {
<span class="nc bnc" id="L562" title="All 2 branches missed.">                    if (templateFileReader != null) templateFileReader.close();</span>
                }
<span class="nc" id="L564">                catch (IOException exp) {</span>
<span class="nc" id="L565">                    LOG.severe(&quot;FAILED: &quot; + templateFile.getPath());</span>
<span class="nc" id="L566">                }</span>
            }
        }
<span class="fc" id="L569">    }</span>

    /**
     * Replace the first occurrences of tokenName with tokenValue.
     *
     * @param line is the line where we do the replacing.
     * @param tokenName is the string we search for.
     * @param tokenValue is the value we replace.
     */
    private void replaceToken(StringBuffer line, String tokenName,
            String tokenValue) {
        int tokenStart;
<span class="nc" id="L581">        tokenStart = line.toString().indexOf(tokenName);</span>
<span class="nc bnc" id="L582" title="All 4 branches missed.">        if ((tokenStart != -1)</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">            &amp;&amp; (tokenValue != null &amp;&amp; tokenValue.length() &gt; 0)) {</span>
<span class="nc" id="L584">            line.replace(tokenStart,</span>
<span class="nc" id="L585">                 tokenStart + tokenName.length(),</span>
                 tokenValue);
        }
<span class="nc" id="L588">    }</span>

    /** 2002-11-28 Achim Spangler
     * separate constant Header Top into function
     */
    private String generateHeaderTop(String pathname) {
<span class="fc" id="L594">        StringBuffer sb = new StringBuffer(80);</span>
        //TODO: add user-defined copyright
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">        if (verboseDocs) {</span>
            // FIXME: replace hard-coded path separator with 
            // CodeGenerator.FILE_SEPARATOR
<span class="nc" id="L599">            sb.append(&quot;// FILE: &quot;).append(pathname.replace('\\', '/'));</span>
<span class="nc" id="L600">            sb.append(LINE_SEPARATOR).append(LINE_SEPARATOR);</span>
        }
<span class="fc" id="L602">        return sb.toString();</span>
    }

    /** 
     * Helper for checkIncludeNeeded4Element. Returns true if
     * an #include is needed.
     */
    private boolean checkInclude4UsageIndirection(boolean isIndirect,
            String usageTag) {
<span class="fc bfc" id="L611" title="All 2 branches covered.">        if (isIndirect) {</span>
            // needs only to be included in the .cpp
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">            if (usageTag.indexOf(&quot;header&quot;) != -1) {</span>
                // but user explicitly requested its presence in the header
<span class="nc bnc" id="L615" title="All 2 branches missed.">                return generatorPass == HEADER_PASS;</span>
            } else {
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">                return generatorPass == SOURCE_PASS;</span>
            }
        }

        // must be included in the header, whatever usageTag is
<span class="fc bfc" id="L622" title="All 2 branches covered.">        return generatorPass == HEADER_PASS;</span>
    }

    private boolean checkIncludeNeeded4Element(Object cls) {
<span class="fc" id="L626">        String usageTag = &quot;&quot;;</span>
<span class="fc" id="L627">        boolean predeclareCandidate = false;</span>

<span class="fc" id="L629">        Iterator iter = getFacade().getTaggedValues(cls);</span>
<span class="fc bfc" id="L630" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L631">            Object tv = iter.next();</span>
<span class="fc" id="L632">            String tag = getFacade().getTagOfTag(tv);</span>
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">            if (tag != null) {</span>
<span class="pc bpc" id="L634" title="1 of 2 branches missed.">                if (tag.equals(TV_NAME_USAGE)) {</span>
<span class="nc" id="L635">                    usageTag = getFacade().getValueOfTag(tv);</span>
                }

<span class="pc bpc" id="L638" title="2 of 4 branches missed.">                if (tag.indexOf(TV_NAME_REFERENCE) != -1 || tag.equals(&quot;&amp;&quot;)</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">                        || tag.indexOf(TV_NAME_POINTER) != -1 </span>
<span class="pc bpc" id="L640" title="1 of 2 branches missed.">                        || tag.equals(&quot;*&quot;)) {</span>
<span class="fc" id="L641">                    predeclareCandidate = true;</span>
                }
            }
<span class="fc" id="L644">        }</span>
<span class="fc" id="L645">        return checkInclude4UsageIndirection(predeclareCandidate, usageTag);</span>
    }

    private StringBuffer generateIncludes(StringBuffer sb) {
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">        for (Iterator it = systemInc.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L650">            String inc = (String) it.next();</span>
<span class="nc" id="L651">            sb.append(&quot;#include &lt;&quot;);</span>
<span class="nc" id="L652">            sb.append(inc).append('&gt;').append(LINE_SEPARATOR);</span>
<span class="nc" id="L653">        }</span>
        // separate system from external headers
<span class="pc bpc" id="L655" title="1 of 2 branches missed.">        if (systemInc.size() &gt; 0) sb.append(LINE_SEPARATOR);</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">        for (Iterator it = extInc.iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L657">            String inc = (String) it.next();</span>
<span class="fc" id="L658">            sb.append(&quot;#include &lt;&quot;);</span>
<span class="fc" id="L659">            sb.append(inc).append('&gt;').append(LINE_SEPARATOR);</span>
<span class="fc" id="L660">        }</span>
        // separate external from local headers
<span class="fc bfc" id="L662" title="All 2 branches covered.">        if (extInc.size() &gt; 0) sb.append(LINE_SEPARATOR);</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">        for (Iterator it = localInc.iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L664">            String inc = (String) it.next();</span>
<span class="fc" id="L665">            sb.append(&quot;#include \&quot;&quot;).append(inc).append(&quot;\&quot;&quot; + LINE_SEPARATOR);</span>
<span class="fc" id="L666">        }</span>
<span class="fc" id="L667">        return sb;</span>
    }

    private StringBuffer generatePredeclare(StringBuffer sb) {
<span class="fc bfc" id="L671" title="All 2 branches covered.">        for (Iterator it = predeclCls.iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L672">            Object cls = it.next();</span>
<span class="fc" id="L673">            String name = getFacade().getName(cls);</span>
<span class="fc" id="L674">            sb.append(generateHeaderPackageStart(cls));</span>
<span class="fc" id="L675">            sb.append(&quot;class &quot;).append(name);</span>
<span class="fc" id="L676">            sb.append(&quot;;&quot;).append(LINE_SEPARATOR);</span>
<span class="fc" id="L677">        }</span>
<span class="fc" id="L678">        sb.append(generateHeaderPackageEnd());</span>
<span class="fc" id="L679">        return sb;</span>
    }

    /**
     * Parses header_incl or source_incl tags and adds the
     * user-specified headers to localInc or systemInc.
     * @param cls The classifier which code is being generated for.
     * @param source if true parses source_incl tags, else header_incl.
     */
    private void addUserHeaders(Object cls, boolean source) {
<span class="fc" id="L689">        Iterator iter = getFacade().getTaggedValues(cls);</span>
        String tagPrefix;
<span class="fc bfc" id="L691" title="All 2 branches covered.">        if (source)</span>
<span class="fc" id="L692">            tagPrefix = TV_NAME_SOURCE_INCL;</span>
        else
<span class="fc" id="L694">            tagPrefix = TV_NAME_HEADER_INCL;</span>
            
<span class="fc bfc" id="L696" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L697">            Object tv = iter.next();</span>
<span class="fc" id="L698">            String tag = getFacade().getTagOfTag(tv);</span>
<span class="pc bpc" id="L699" title="3 of 4 branches missed.">            if (tag != null &amp;&amp; tag.equals(tagPrefix)) {</span>
<span class="nc" id="L700">                String name = getFacade().getValueOfTag(tv);</span>
<span class="nc bnc" id="L701" title="All 4 branches missed.">                if (name.length() &gt; 2 &amp;&amp; name.charAt(0) == '&lt;') {</span>
<span class="nc" id="L702">                    systemInc.add(name.substring(1, name.length() - 1));</span>
<span class="nc bnc" id="L703" title="All 4 branches missed.">                } else if (name.length() &gt; 2 &amp;&amp; name.charAt(0) == '&quot;') {</span>
<span class="nc" id="L704">                    localInc.add(name.substring(1, name.length() - 1));</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">                } else if (name.length() &gt; 0) { // skip empty values</span>
<span class="nc" id="L706">                    localInc.add(name);</span>
                }
            }
<span class="fc" id="L709">        }</span>
<span class="fc" id="L710">    }</span>

    /**
     * Adds dep to the set of dependencies of currClass. If predecl
     * then only a predeclaration is generated, else an #include.
     * @param dep The classifier whose currClass depends on.
     * @param predecl If true then only a predeclaration is needed
     */
    private void addDependency(Object dep, boolean predecl) {
<span class="fc bfc" id="L719" title="All 2 branches covered.">        if (generatorPass == NONE_PASS) {</span>
<span class="fc" id="L720">            return; // skip dependencies if generating notation</span>
        }
<span class="fc bfc" id="L722" title="All 4 branches covered.">        if (!(getFacade().isAClass(dep)) &amp;&amp; !(getFacade().isAInterface(dep))) {</span>
            // Do nothing for things such as datatypes, etc.
            // TODO: check for namespace when using directives are implemented
<span class="fc" id="L725">            return;</span>
        }
<span class="fc bfc" id="L727" title="All 4 branches covered.">        if (predecl &amp;&amp; !includeCls.contains(dep)) {</span>
<span class="fc bfc" id="L728" title="All 2 branches covered.">            if (generatorPass == HEADER_PASS) {</span>
<span class="fc" id="L729">                predeclCls.add(dep);</span>
            }
        } else {
<span class="pc bpc" id="L732" title="1 of 2 branches missed.">            if (predeclCls.contains(dep)) {</span>
<span class="nc" id="L733">                predeclCls.remove(dep);</span>
            }
<span class="fc bfc" id="L735" title="All 2 branches covered.">            if (includeCls.add(dep)) {</span>
                // dep was not already in includeCls
<span class="fc" id="L737">                Object ns = getFacade().getNamespace(currClass);</span>
<span class="fc" id="L738">                String name = getFacade().getName(dep);</span>
                // use '/', not FILE_SEPARATOR (this is intentional)
<span class="fc" id="L740">                String path =</span>
<span class="fc" id="L741">                    generateRelativePackage(dep, ns, &quot;/&quot;);</span>
<span class="fc" id="L742">                Set inc = localInc;</span>
<span class="fc bfc" id="L743" title="All 2 branches covered.">                if (path.startsWith(&quot;/&quot;)) { // external include</span>
<span class="fc" id="L744">                    path = path.substring(1); // remove leading /</span>
<span class="fc" id="L745">                    inc = extInc;</span>
                }
<span class="fc bfc" id="L747" title="All 2 branches covered.">                if (path.length() &gt; 0) {</span>
<span class="fc" id="L748">                    inc.add(path + &quot;/&quot; + name + &quot;.h&quot;);</span>
                } else {
<span class="fc" id="L750">                    inc.add(name + &quot;.h&quot;);</span>
                }
            }
        }
<span class="fc" id="L754">    }</span>

    private String generateHeaderPackageStartSingle(Object pkg) {
<span class="fc" id="L757">        StringBuffer sb = new StringBuffer(30);</span>
<span class="fc" id="L758">        String packageName = getFacade().getName(pkg);</span>
<span class="fc" id="L759">        StringTokenizer st = new StringTokenizer(packageName, &quot;.&quot;);</span>
<span class="fc" id="L760">        String token = &quot;&quot;;</span>

<span class="fc" id="L762">        sb.append(generateTaggedValues(pkg, DOC_COMMENT_TAGS));</span>
<span class="fc bfc" id="L763" title="All 2 branches covered.">        while (st.hasMoreTokens()) {</span>
<span class="fc" id="L764">            token = st.nextToken();</span>
            // create line: namespace FOO {&quot;
<span class="fc" id="L766">            sb.append(&quot;namespace &quot;).append(token).append(&quot; {&quot;)</span>
<span class="fc" id="L767">                .append(LINE_SEPARATOR);</span>
        }
<span class="fc" id="L769">        return sb.toString();</span>
    }

    private String generateHeaderPackageEndSingle(Object pkg) {
<span class="fc" id="L773">        StringBuffer sb = new StringBuffer(30);</span>
<span class="fc" id="L774">        String packageName = getFacade().getName(pkg);</span>
<span class="fc" id="L775">        StringTokenizer st = new StringTokenizer(packageName, &quot;.&quot;);</span>
<span class="fc" id="L776">        String token = &quot;&quot;;</span>
<span class="fc bfc" id="L777" title="All 2 branches covered.">        while (st.hasMoreTokens()) {</span>
<span class="fc" id="L778">            token = st.nextToken();</span>
<span class="fc" id="L779">            StringBuffer tempBuf = new StringBuffer(20);</span>
<span class="fc" id="L780">            String absoluteName = generatePackageAbsoluteName(pkg);</span>
<span class="pc bpc" id="L781" title="1 of 2 branches missed.">            if (absoluteName.indexOf(token) != -1) {</span>
<span class="fc" id="L782">                absoluteName =</span>
<span class="fc" id="L783">                    absoluteName.substring(0,</span>
<span class="fc" id="L784">                               (absoluteName.indexOf(token)</span>
<span class="fc" id="L785">                                + token.length()));</span>
            }

            // create line: namespace FOO {&quot;
<span class="fc" id="L789">            tempBuf.append(&quot;} /* End of namespace &quot;).append(absoluteName);</span>
<span class="fc" id="L790">            tempBuf.append(&quot; */&quot;).append(LINE_SEPARATOR);</span>
<span class="fc" id="L791">            sb.insert(0, tempBuf.toString());</span>
<span class="fc" id="L792">        }</span>
<span class="fc" id="L793">        return sb.toString();</span>
    }

    private String generatePackageAbsoluteName(Object pkg) {
<span class="fc" id="L797">        String pack = generateRelativePackage(pkg, null, &quot;::&quot;);</span>
<span class="fc" id="L798">        pack = pack.substring(2); // remove leading ::</span>
<span class="pc bpc" id="L799" title="1 of 2 branches missed.">        if (pack.length() &gt; 0) {</span>
<span class="nc" id="L800">            pack += &quot;::&quot;;</span>
        }
<span class="fc" id="L802">        return pack + getFacade().getName(pkg);</span>
    }

    /** Generate the name of item with package prefix relative to localPkg.
     * localPkg may be null, meaning the global namespace.
     */
    private String generateNameWithPkgSelection(Object item, Object localPkg) {
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">        if (item == null) {</span>
<span class="nc" id="L810">            return &quot;void &quot;;</span>
        }
<span class="fc" id="L812">        Object pkg = null;</span>
<span class="fc bfc" id="L813" title="All 2 branches covered.">        if (getFacade().isADataType(item)) {</span>
<span class="fc" id="L814">            return getFacade().getName(item);</span>
<span class="pc bpc" id="L815" title="1 of 2 branches missed.">        } else if (getFacade().isAParameter(item)</span>
<span class="pc bpc" id="L816" title="1 of 2 branches missed.">                   || getFacade().isAAttribute(item)</span>
<span class="pc bpc" id="L817" title="1 of 2 branches missed.">                   || getFacade().isAAssociationEnd(item)</span>
<span class="pc bpc" id="L818" title="1 of 2 branches missed.">                   || getFacade().isAClassifier(item)) {</span>
<span class="fc" id="L819">            pkg = getNamespaceWithoutModel(item);</span>
        }

<span class="fc bfc" id="L822" title="All 2 branches covered.">        if (pkg == null) {</span>
<span class="fc" id="L823">            return getFacade().getName(item);</span>
        }
<span class="fc" id="L825">        String packPrefix = generateRelativePackage(item, localPkg, &quot;::&quot;);</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">        if (packPrefix.length() &gt; 0) {</span>
<span class="fc" id="L827">            packPrefix += &quot;::&quot;;</span>
        }
<span class="fc" id="L829">        return packPrefix + getFacade().getName(item);</span>
    }

    /** Generate name with package specs, relative to actualNamespace.
     */
    private String generateNameWithPkgSelection(Object item) {
<span class="fc" id="L835">        Object pkg = actualNamespace;</span>
<span class="fc" id="L836">        String name = generateNameWithPkgSelection(item, pkg);</span>
<span class="fc bfc" id="L837" title="All 2 branches covered.">        if (name.startsWith(&quot;::&quot;)) {</span>
<span class="fc" id="L838">            name = name.substring(2); // remove leading ::</span>
            // the leading :: is just ugly to see, but it could
            // be left there to emphasize that item is in the
            // global namespace
        }
<span class="fc" id="L843">        return name;</span>
    }

    /** Generate the code to go from the current namespace to cls's one
     */
    private String generateHeaderPackageStart(Object cls) {
<span class="fc" id="L849">        StringBuffer sb = new StringBuffer(80);</span>

<span class="pc bpc" id="L851" title="1 of 2 branches missed.">        if (actualNamespace != null) {</span>
<span class="nc" id="L852">            Object lastSearch = actualNamespace;</span>
            // iterate while fromSearch != null, but iterate one time
            // when it is null too, because it's the global namespace
<span class="nc" id="L855">            for (Object fromSearch = actualNamespace;</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">                    fromSearch != null;</span>
<span class="nc" id="L857">                    lastSearch = getNamespaceWithoutModel(fromSearch)) {</span>
<span class="nc" id="L858">                fromSearch = lastSearch;</span>
<span class="nc" id="L859">                StringBuffer contPath = new StringBuffer(80);</span>
<span class="nc" id="L860">                Object toSearch = getNamespaceWithoutModel(cls);</span>
<span class="nc bnc" id="L861" title="All 4 branches missed.">                for (; (toSearch != null) &amp;&amp; (toSearch != fromSearch);</span>
<span class="nc" id="L862">                        toSearch = getNamespaceWithoutModel(toSearch)) {</span>
<span class="nc" id="L863">                    contPath.insert(0,</span>
<span class="nc" id="L864">                            generateHeaderPackageStartSingle(toSearch));</span>
                }
<span class="nc bnc" id="L866" title="All 2 branches missed.">                if (toSearch == fromSearch) {</span>
<span class="nc" id="L867">                    sb.append(contPath.toString());</span>
<span class="nc" id="L868">                    break;</span>
                }
                // close one namespace
<span class="nc" id="L871">                sb.append(generateHeaderPackageEndSingle(fromSearch));</span>
            }
<span class="nc" id="L873">        }</span>
        else { // initial start
<span class="fc" id="L875">            for (Object toSearch = getNamespaceWithoutModel(cls);</span>
<span class="fc bfc" id="L876" title="All 2 branches covered.">                    toSearch != null;</span>
<span class="fc" id="L877">                    toSearch = getNamespaceWithoutModel(toSearch)) {</span>
<span class="fc" id="L878">                sb.insert(0, generateHeaderPackageStartSingle(toSearch));</span>
            }
        }
<span class="fc" id="L881">        actualNamespace = getNamespaceWithoutModel(cls);</span>
<span class="fc" id="L882">        return sb.toString();</span>
    }

    /**
     * Retrieve the namespace of the given model element, excluding the model,
     * which shouldn't be considered a namespace.
     * @param me the model element for which to get the namespace
     * @return the namespace if it exists or null if the model is the
     * containing namespace for &lt;code&gt;me&lt;/code&gt;
     */
    private Object getNamespaceWithoutModel(Object me) {
<span class="fc" id="L893">        Object parent = getFacade().getNamespace(me);</span>
<span class="pc bpc" id="L894" title="1 of 4 branches missed.">        if (parent != null &amp;&amp; getFacade().getNamespace(parent) != null) </span>
<span class="fc" id="L895">            return parent;</span>
<span class="fc" id="L896">        return null;</span>
    }

    private String generateHeaderPackageEnd() {
<span class="fc" id="L900">        StringBuffer sb = new StringBuffer(20);</span>

<span class="fc" id="L902">        for (Object closeIt = actualNamespace;</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">                closeIt != null;</span>
<span class="fc" id="L904">                closeIt = getNamespaceWithoutModel(closeIt)) {</span>
<span class="fc" id="L905">            sb.append(generateHeaderPackageEndSingle(closeIt));</span>
        }
<span class="fc" id="L907">        actualNamespace = null;</span>
<span class="fc" id="L908">        return sb.toString();</span>
    }

    /* This generates the file internal header, not the .h file!
     * That is, things before the class declaration.
     */
    private String generateHeader(Object cls) {
<span class="fc" id="L915">        StringBuffer sb = new StringBuffer(240);</span>

<span class="fc bfc" id="L917" title="All 2 branches covered.">        addUserHeaders(cls, generatorPass == SOURCE_PASS);</span>

<span class="fc bfc" id="L919" title="All 2 branches covered.">        if (getNamespaceWithoutModel(cls) != null) {</span>
<span class="fc" id="L920">            String pkgstart = generateHeaderPackageStart(cls);</span>
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">            if (pkgstart.length() &gt; 0) {</span>
<span class="fc" id="L922">                sb.append(LINE_SEPARATOR);</span>
<span class="fc" id="L923">                sb.append(pkgstart);</span>
            }
        }

<span class="fc" id="L927">        return sb.toString();</span>
    }

    /* 
     * This generates all the things that go after the class declaration.
     */
    private String generateFooter() {
<span class="fc" id="L934">        StringBuffer sb = new StringBuffer(80);</span>
<span class="fc" id="L935">        sb.append(generateHeaderPackageEnd());</span>
<span class="fc bfc" id="L936" title="All 2 branches covered.">        if (sb.length() &gt; 0) {</span>
<span class="fc" id="L937">            sb.insert(0, LINE_SEPARATOR);</span>
        }
<span class="fc" id="L939">        return sb.toString();</span>
    }

    /** 2002-11-28 Achim Spangler
     * separate generation of Operation Prefix from generateOperation
     * so that generateOperation is language independent
     */
    private String generateOperationPrefix(Object op) {
<span class="fc" id="L947">        StringBuffer sb = new StringBuffer(80);</span>
        // c++ doesn't have any builtin construct for concurrency
        //sb.append(generateConcurrency(op));
<span class="fc bfc" id="L950" title="All 2 branches covered.">        if (generatorPass != SOURCE_PASS) {</span>
            // make all operations to virtual - as long as they are not &quot;leaf&quot;
<span class="pc bpc" id="L952" title="3 of 4 branches missed.">            if (getFacade().isLeaf(op) &amp;&amp; !getFacade().isRoot(op)) {</span>
                // there's no way to make a leaf method that it's not root in
                // c++, so warn the user and ignore the 'root' attribute
                // (or it may be better to ignore the 'leaf' attribute?)
<span class="nc" id="L956">                LOG.warning(op + &quot; is leaf but not root: &quot;</span>
                             + &quot;C++ can't handle this properly&quot;);
<span class="nc" id="L958">                LOG.warning(&quot;    Ignoring the 'root' attribute&quot;);</span>
            }
            // generate a function as virtual, if it can be overridden
            // or override another function AND if this function is
            // not marked as static, which disallows &quot;virtual&quot;
            // alternatively every abstract function is defined as
            // virtual
<span class="pc bpc" id="L965" title="1 of 4 branches missed.">            if ((!getFacade().isLeaf(op) &amp;&amp; !getFacade().isConstructor(op)</span>
<span class="pc bpc" id="L966" title="1 of 2 branches missed.">                    &amp;&amp; (!(getFacade().isStatic(op))))</span>
<span class="pc bpc" id="L967" title="1 of 2 branches missed.">                    || (getFacade().isAbstract(op))) {</span>
<span class="fc" id="L968">                sb.append(&quot;virtual &quot;);</span>
            }
<span class="fc" id="L970">            sb.append(generateScope(op));</span>
        }
<span class="fc" id="L972">        return sb.toString();</span>
    }

    /** 2002-11-28 Achim Spangler
     * separate generation of Operation Suffix from generateOperation
     * so that generateOperation is language independent
     */
    private String generateOperationSuffix(Object op) {
<span class="fc" id="L980">        StringBuffer sb = new StringBuffer(80);</span>
<span class="fc" id="L981">        sb.append(generateOperationChangeability(op));</span>
<span class="fc" id="L982">        sb.append(generateAbstractness(op));</span>
<span class="fc" id="L983">        return sb.toString();</span>
    }

    /** 2002-11-28 Achim Spangler
     * separate generation of Operation Name from generateOperation
     * so that generateOperation is language independent
     * -&gt; for C++: if we create .cpp we must prepend Owner name
     *
     * @param sb Where to put the result.
     */
    private void generateOperationNameAndTestForConstructor(Object op,
            StringBuffer sb) {
<span class="fc bfc" id="L995" title="All 2 branches covered.">        if (generatorPass == SOURCE_PASS) {</span>
<span class="fc" id="L996">            Object cls = getFacade().getOwner(op);</span>
<span class="fc" id="L997">            String prefix = new String();</span>
<span class="fc bfc" id="L998" title="All 2 branches covered.">            while (!getFacade().isAPackage(cls)) {</span>
<span class="fc" id="L999">                prefix = getFacade().getName(cls) + &quot;::&quot; + prefix;</span>
<span class="fc" id="L1000">                cls = getFacade().getNamespace(cls);</span>
            }
<span class="fc" id="L1002">            sb.append(prefix);</span>
        }
        String name;
<span class="fc bfc" id="L1005" title="All 2 branches covered.">        if (getFacade().isConstructor(op)) {</span>
<span class="fc" id="L1006">            name = getFacade().getName(getFacade().getOwner(op));</span>
<span class="fc bfc" id="L1007" title="All 2 branches covered.">        } else if (isDestructor(op)) {</span>
<span class="fc" id="L1008">            name = &quot;~&quot; + getFacade().getName(getFacade().getOwner(op));</span>
        } else {
<span class="fc" id="L1010">            name = getFacade().getName(op);</span>
        }
<span class="fc" id="L1012">        sb.append(name);</span>
<span class="fc" id="L1013">    }</span>

    private boolean isDestructor(Object op) {
<span class="fc" id="L1016">        return getExtensionMechanismsHelper().hasStereotype(op, &quot;destroy&quot;);</span>
    }

    /**
     * Generate code for an operation.
     * 
     * 2002-11-28 Achim Spangler
     * modified version from Jaap Branderhorst
     * -&gt; generateOperation is language independent and separates
     *    different tasks
     * @param op The operation for which to generate code.
     * @param documented If the documentation should be included in the 
     * generated code or not.
     * @return The C++ code for the operation.
     */
    public String generateOperation(Object op, boolean documented) {
        // generate nothing for abstract functions, if we generate the
        // source .cpp file at the moment
<span class="pc bpc" id="L1034" title="1 of 4 branches missed.">        if ((generatorPass == SOURCE_PASS) &amp;&amp; (getFacade().isAbstract(op))) {</span>
<span class="nc" id="L1035">            return &quot;&quot;;</span>
        }
<span class="fc" id="L1037">        StringBuffer sb = new StringBuffer(80);</span>
<span class="fc" id="L1038">        StringBuffer nameBuffer = new StringBuffer(20);</span>
<span class="fc bfc" id="L1039" title="All 2 branches covered.">        String operationIndent = (generatorPass == HEADER_PASS) ? indent : &quot;&quot;;</span>
<span class="fc" id="L1040">        generateOperationNameAndTestForConstructor(op, nameBuffer);</span>

        // if generating a file always document
<span class="pc bpc" id="L1043" title="1 of 4 branches missed.">        if (documented || generatorPass != NONE_PASS) {</span>
            // generate DocComment from tagged values
<span class="fc" id="L1045">            String tv = generateTaggedValues (op, DOC_COMMENT_TAGS);</span>
<span class="pc bpc" id="L1046" title="2 of 4 branches missed.">            if (tv != null &amp;&amp; tv.length() &gt; 0) {</span>
<span class="nc" id="L1047">                sb.append (LINE_SEPARATOR).append(operationIndent).append (tv);</span>
            }
        }

<span class="fc" id="L1051">        sb.append(operationIndent)</span>
<span class="fc" id="L1052">            .append(generateOperationPrefix(op));</span>

        // pick out return type
<span class="fc" id="L1055">        Collection returnParams = getCoreHelper().getReturnParameters(op);</span>
        Object rp;
<span class="pc bpc" id="L1057" title="1 of 2 branches missed.">        if (returnParams.size() == 0) {</span>
<span class="nc" id="L1058">            rp = null;</span>
        } else {
<span class="fc" id="L1060">            rp = returnParams.iterator().next();</span>
        } 
<span class="pc bpc" id="L1062" title="1 of 2 branches missed.">        if (returnParams.size() &gt; 1)  {</span>
<span class="nc" id="L1063">            LOG.warning(&quot;C++ generator only handles one return parameter&quot;</span>
<span class="nc" id="L1064">                        + &quot; - Found &quot; + returnParams.size()</span>
<span class="nc" id="L1065">                        + &quot; for &quot; + getFacade().getName(op));</span>
        }
<span class="fc bfc" id="L1067" title="All 4 branches covered.">        if (!getFacade().isConstructor(op) &amp;&amp; !isDestructor(op)) {</span>
<span class="fc" id="L1068">            Inline inlineStyle = Inline.getInlineOperationModifierType(op);</span>
<span class="fc" id="L1069">            sb.append(inlineStyle.getInlineKeyword4Declaration());</span>
            
<span class="pc bpc" id="L1071" title="1 of 2 branches missed.">            if (rp != null) {</span>
<span class="fc" id="L1072">                Object returnType = getFacade().getType(rp);</span>
<span class="pc bpc" id="L1073" title="1 of 2 branches missed.">                if (returnType == null) {</span>
<span class="nc" id="L1074">                    sb.append(&quot;void &quot;);</span>
                }
<span class="pc bpc" id="L1076" title="1 of 2 branches missed.">                else if (returnType != null) {</span>
<span class="fc" id="L1077">                    sb.append(generateNameWithPkgSelection(returnType))</span>
<span class="fc" id="L1078">                        .append(' ');</span>
                    /* fixing 2862 - apply modifiers, 
                     * i.e. pointer or reference TV */
<span class="fc" id="L1081">                    sb.append(generateAttributeParameterModifier(rp));</span>
                }
<span class="fc bfc" id="L1083" title="All 2 branches covered.">                boolean predecl = !checkIncludeNeeded4Element(rp);</span>
<span class="fc" id="L1084">                addDependency(returnType, predecl);</span>
            }
        }

        // name and params
<span class="fc" id="L1089">        Vector params = new Vector(getFacade().getParameters(op));</span>
<span class="fc" id="L1090">        params.remove(rp); // If there are several return parameters, just</span>
                           // the one found above will be removed.

<span class="fc" id="L1093">        sb.append(nameBuffer.toString()).append('(');</span>

<span class="pc bpc" id="L1095" title="1 of 2 branches missed.">        if (params != null) {</span>
<span class="fc" id="L1096">            boolean first = true;</span>

<span class="fc bfc" id="L1098" title="All 2 branches covered.">            for (int i = 0; i &lt; params.size(); i++) {</span>
<span class="fc" id="L1099">                Object p = params.elementAt (i);</span>

<span class="pc bpc" id="L1101" title="1 of 2 branches missed.">                if (!first) sb.append(&quot;, &quot;);</span>

<span class="fc" id="L1103">                sb.append(generateParameter(p));</span>
<span class="fc" id="L1104">                first = false;</span>
            }
        }

<span class="fc" id="L1108">        String suffix = generateOperationSuffix(op);</span>
<span class="pc bpc" id="L1109" title="1 of 2 branches missed.">        if (suffix.equals(&quot;&quot;))</span>
<span class="fc" id="L1110">            sb.append(&quot;)&quot;);</span>
        else
<span class="nc" id="L1112">            sb.append(&quot;) &quot;).append(suffix);</span>

<span class="fc" id="L1114">        return sb.toString();</span>
    }

    /** 2002-12-06 Achim Spangler
     * check if a parameter is tagged as pointer or reference (not
     * part of UML - as far as author knows - but important for C++
     * developers)
     * @param elem element to check
     * @return one of NORMAL_MOD, REFERENCE_MOD, POINTER_MOD, or -1 if
     *         no specific tag is found
     */
    private int getAttributeModifierType(Object elem) {
        // first check whether the parameter shall be a pointer of reference
<span class="fc" id="L1127">        Iterator iter = getFacade().getTaggedValues(elem);</span>
<span class="fc bfc" id="L1128" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L1129">            Object tv = iter.next();</span>
<span class="fc" id="L1130">            String tag = getFacade().getTagOfTag(tv);</span>
<span class="fc" id="L1131">            String val = getFacade().getValueOfTag(tv);</span>
<span class="pc bpc" id="L1132" title="1 of 2 branches missed.">            if (tag != null) {</span>
<span class="pc bpc" id="L1133" title="2 of 4 branches missed.">                if (tag.equals(TV_NAME_REFERENCE) || tag.equals(&quot;&amp;&quot;)) {</span>
<span class="nc bnc" id="L1134" title="All 2 branches missed.">                    return val.equals(&quot;false&quot;) ? NORMAL_MOD</span>
<span class="nc" id="L1135">                            : REFERENCE_MOD;</span>
<span class="pc bpc" id="L1136" title="1 of 4 branches missed.">                } else if (tag.equals(TV_NAME_POINTER) || tag.equals(&quot;*&quot;)) {</span>
<span class="pc bpc" id="L1137" title="1 of 2 branches missed.">                    return val.equals(&quot;false&quot;) ? NORMAL_MOD</span>
<span class="fc" id="L1138">                            : POINTER_MOD;</span>
                }
            }
<span class="fc" id="L1141">        }</span>
<span class="fc" id="L1142">        return -1; /* no tag found */</span>
    }


    private String generateAttributeParameterModifier(Object attr,
                                                      String def) {
<span class="fc" id="L1148">        int modType = getAttributeModifierType(attr);</span>

        // if attr has an abstract type it must be pointer or reference
<span class="pc bpc" id="L1151" title="1 of 4 branches missed.">        if (modType == NORMAL_MOD || modType == -1) {</span>
            // this is used for association classes to; skip them
<span class="pc bpc" id="L1153" title="1 of 2 branches missed.">            if (!getFacade().isAAssociationClass(attr)) {</span>
<span class="fc" id="L1154">                Object type = getFacade().getType(attr);</span>
<span class="pc bpc" id="L1155" title="1 of 2 branches missed.">                if (type == null) {</span>
                    // model corrupt (this really happened -- aslo)
<span class="nc" id="L1157">                    LOG.severe(attr + &quot; has no type!&quot;);</span>
<span class="nc" id="L1158">                    return &quot;&quot;;</span>
                }
<span class="pc bpc" id="L1160" title="1 of 2 branches missed.">                if (getFacade().isAbstract(type)</span>
<span class="pc bpc" id="L1161" title="1 of 2 branches missed.">                    || getFacade().isAInterface(type)) {</span>
<span class="nc bnc" id="L1162" title="All 2 branches missed.">                    if (modType == NORMAL_MOD) {</span>
                        // user explicitly requested no modifier
<span class="nc" id="L1164">                        LOG.warning(&quot;Requested no reference or pointer &quot;</span>
                                    + &quot;modifier, but&quot;);
<span class="nc" id="L1166">                        LOG.warning(&quot;\t&quot; + type + &quot; cannot be instantiated, &quot;</span>
                                    + &quot;using reference&quot;);
                    }
<span class="nc" id="L1169">                    modType = REFERENCE_MOD;</span>
                }
            }
        }

<span class="pc bpc" id="L1174" title="1 of 2 branches missed.">        if (modType == NORMAL_MOD) {</span>
<span class="nc" id="L1175">            return &quot;&quot;;</span>
<span class="pc bpc" id="L1176" title="1 of 2 branches missed.">        } else if (modType == REFERENCE_MOD) {</span>
<span class="nc" id="L1177">            return &quot;&amp;&quot;;</span>
<span class="fc bfc" id="L1178" title="All 2 branches covered.">        } else if (modType == POINTER_MOD) {</span>
<span class="fc" id="L1179">            return &quot;*&quot;;</span>
<span class="pc bpc" id="L1180" title="1 of 2 branches missed.">        } else if (def.length() == 0) {</span>
<span class="fc bfc" id="L1181" title="All 2 branches covered.">            if (getFacade().isAParameter(attr)</span>
<span class="pc bpc" id="L1182" title="1 of 2 branches missed.">                    &amp;&amp; (getDirectionKind().getOutParameter().equals(</span>
<span class="fc" id="L1183">                        getFacade().getKind(attr))</span>
<span class="pc bpc" id="L1184" title="1 of 2 branches missed.">                    || getDirectionKind().getInOutParameter().equals(</span>
<span class="fc" id="L1185">                        getFacade().getKind(attr)))) {</span>
                // out or inout parameters are defaulted to reference if
                // not specified else
<span class="nc" id="L1188">                return &quot;&amp;&quot;;</span>
            }
        }
<span class="fc" id="L1191">        return def;</span>
    }

    /**
     * @param elem element to check
     * @return CONST_MOD or -1 if no specific tag is found
     */
    private int getConstAttributeModifierType(Object elem) {
<span class="fc" id="L1199">        Iterator iter = getFacade().getTaggedValues(elem);</span>
<span class="fc bfc" id="L1200" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L1201">            Object tv = iter.next();</span>
<span class="fc" id="L1202">            String tag = getFacade().getTagOfTag(tv);</span>
<span class="fc" id="L1203">            String val = getFacade().getValueOfTag(tv);</span>
<span class="pc bpc" id="L1204" title="1 of 2 branches missed.">            if (tag != null) {</span>
<span class="pc bpc" id="L1205" title="1 of 2 branches missed.">                if (tag.equals(TV_NAME_CONST)) {</span>
<span class="pc bpc" id="L1206" title="1 of 2 branches missed.">                    return val.equals(&quot;false&quot;) ? NORMAL_MOD : CONST_MOD;</span>
                }
            }
<span class="nc" id="L1209">        }    </span>
<span class="fc" id="L1210">        return -1; /* no tag found */</span>
    }

    private String generateConstAttributeParameterModifier(Object attr) {
<span class="fc bfc" id="L1214" title="All 2 branches covered.">    	if (getConstAttributeModifierType(attr) == CONST_MOD) {</span>
<span class="fc" id="L1215">    	    return &quot;const&quot;;</span>
    	}
<span class="fc" id="L1217">    	return null;</span>
    }

    private String generateAttributeParameterModifier(Object attr) {
<span class="fc" id="L1221">        return generateAttributeParameterModifier(attr, &quot;&quot;);</span>
    }


    public String generateAttribute(Object attr, boolean documented) {
<span class="fc" id="L1226">        StringBuffer sb = new StringBuffer(80);</span>

        // list tagged values for documentation
<span class="pc bpc" id="L1229" title="2 of 4 branches missed.">        if (documented || generatorPass != NONE_PASS) {</span>
<span class="nc" id="L1230">            String tv = generateTaggedValues (attr, DOC_COMMENT_TAGS);</span>
<span class="nc bnc" id="L1231" title="All 4 branches missed.">            if (tv != null &amp;&amp; tv.length() &gt; 0) {</span>
<span class="nc" id="L1232">                sb.append (LINE_SEPARATOR).append(indent).append(tv).</span>
<span class="nc" id="L1233">                    append(indent);</span>
            }
        }
        // cat.info(&quot;generate Visibility for Attribute&quot;);
<span class="fc" id="L1237">        sb.append(generateVisibility(attr));</span>
<span class="fc" id="L1238">        sb.append(generateScope(attr));</span>
<span class="fc" id="L1239">        sb.append(generateStructuralFeatureChangeability(attr));</span>
<span class="fc" id="L1240">        sb.append(</span>
<span class="fc" id="L1241">                generateMultiplicity(attr, getFacade().getName(attr), </span>
<span class="fc" id="L1242">                        getFacade().getMultiplicity(attr),</span>
<span class="fc" id="L1243">                        generateAttributeParameterModifier(attr)));</span>
<span class="fc" id="L1244">        sb.append(&quot;;&quot;);</span>
<span class="pc bpc" id="L1245" title="1 of 2 branches missed.">        if (generatorPass != NONE_PASS)</span>
<span class="nc" id="L1246">            sb.append(LINE_SEPARATOR);</span>

        // add the type of the attribute in the dependency list
<span class="pc bpc" id="L1249" title="1 of 2 branches missed.">        boolean predecl = !checkIncludeNeeded4Element(attr);</span>
<span class="fc" id="L1250">        addDependency(getFacade().getType(attr), predecl);</span>

<span class="fc" id="L1252">        return sb.toString();</span>
    }


    private String generateParameter(Object param) {
<span class="fc" id="L1257">        StringBuffer sb = new StringBuffer(20);</span>
        //TODO: qualifiers (e.g., const)
        // generate const for references or pointers which are
        // defined as IN - other qualifiers are not important for
        // C++ parameters
<span class="fc" id="L1262">        Object type = getFacade().getType(param);</span>
<span class="fc" id="L1263">        sb.append(generateParameterChangeability(param));</span>
        //TODO: stereotypes...
<span class="fc" id="L1265">        String constModifier = generateConstAttributeParameterModifier(param); </span>
<span class="fc bfc" id="L1266" title="All 2 branches covered.">        if (constModifier != null) {</span>
<span class="fc" id="L1267">            sb.append(constModifier).append(' ');</span>
        }
<span class="fc" id="L1269">        sb.append(generateNameWithPkgSelection(type));</span>
<span class="fc" id="L1270">        sb.append(' ');</span>
<span class="fc" id="L1271">        sb.append(generateAttributeParameterModifier(param));</span>
<span class="fc" id="L1272">        sb.append(getFacade().getName(param));</span>

        // insert default value, if we are generating the header or notation
<span class="fc bfc" id="L1275" title="All 2 branches covered.">        if (generatorPass != SOURCE_PASS) {</span>
<span class="fc" id="L1276">            Object defvalObj = getFacade().getDefaultValue(param);</span>
<span class="pc bpc" id="L1277" title="1 of 2 branches missed.">            if (defvalObj != null) {</span>
                String defval =
<span class="nc" id="L1279">                    getFacade().getBody(defvalObj).toString().trim();</span>
<span class="nc bnc" id="L1280" title="All 2 branches missed.">                if (defval.length() &gt; 0) {</span>
<span class="nc" id="L1281">                    sb.append(&quot; = &quot;).append(defval);</span>
                }
            }
        }

        // add the type of the parameter in the dependency list
<span class="fc bfc" id="L1287" title="All 2 branches covered.">        boolean predecl = !checkIncludeNeeded4Element(param);</span>
<span class="fc" id="L1288">        addDependency(type, predecl);</span>

<span class="fc" id="L1290">        return sb.toString();</span>
    }


    /**
     * Generate the start sequence for a classifier. The start sequence is
     * everything from the preceding javadoc comment to the opening curly brace.
     * Start sequences are non-empty for classes and interfaces only.
     *
     * This method is intended for package internal usage only.
     *
     * @param cls the classifier for which to generate the start sequence
     *
     * @return the generated start sequence
     */
    StringBuffer generateClassifierStart(Object cls) {
<span class="fc" id="L1306">        StringBuffer sb = new StringBuffer (80);</span>
        // Add the comments for this classifier first.
<span class="fc" id="L1308">        sb.append(LINE_SEPARATOR)</span>
<span class="fc" id="L1309">            .append (DocumentationManager.getComments(cls));</span>

        // list tagged values for documentation
<span class="fc" id="L1312">        String tv = generateTaggedValues (cls, DOC_COMMENT_TAGS);</span>
<span class="pc bpc" id="L1313" title="2 of 4 branches missed.">        if (tv != null &amp;&amp; tv.length() &gt; 0) {</span>
<span class="nc" id="L1314">            sb.append (LINE_SEPARATOR).append (indent).append (tv);</span>
        }
        
<span class="fc" id="L1317">        sb.append(generateClassifierNameAndAncestors(cls));</span>

        // add opening brace
<span class="pc bpc" id="L1320" title="1 of 2 branches missed.">        if (lfBeforeCurly) {</span>
<span class="nc" id="L1321">            sb.append(LINE_SEPARATOR).append('{');</span>
<span class="fc bfc" id="L1322" title="All 2 branches covered.">        } else if (generatorPass != SOURCE_PASS) {</span>
<span class="fc" id="L1323">            sb.append(&quot; {&quot;);</span>
        }

        // list tagged values for documentation
<span class="fc" id="L1327">        tv = generateTaggedValues (cls, ALL_BUT_DOC_TAGS);</span>
<span class="pc bpc" id="L1328" title="2 of 4 branches missed.">        if (tv != null &amp;&amp; tv.length() &gt; 0) {</span>
<span class="nc" id="L1329">            sb.append(LINE_SEPARATOR).append (indent).append (tv);</span>
        }

<span class="fc" id="L1332">        return sb;</span>
    }
    
    /**
     * Generate the classifier name and ancestors, i.e., the keyword defining 
     * the class, the class name and the name of the classes from which this
     * one derives.
     *
     * @param cls the classifier for which to generate the name and ancestors
     *
     * @return the generated name and ancestors
     */
    public StringBuffer generateClassifierNameAndAncestors(Object cls) {
<span class="fc" id="L1345">        StringBuffer sb = new StringBuffer (80);</span>

        // don't create class-Start for implementation in .cpp
<span class="fc bfc" id="L1348" title="All 2 branches covered.">        if (generatorPass == SOURCE_PASS) return sb;</span>

        String sClassifierKeyword;
<span class="pc bpc" id="L1351" title="3 of 4 branches missed.">        if (getFacade().isAClass(cls) || getFacade().isAInterface(cls)) {</span>
<span class="fc" id="L1352">            sClassifierKeyword = &quot;class&quot;;</span>
        } else {
<span class="nc" id="L1354">            return null; // actors, use cases etc.</span>
        }
<span class="fc" id="L1356">        boolean hasBaseClass = false;</span>

        // add classifier keyword and classifier name
<span class="fc" id="L1359">        sb.append(sClassifierKeyword).append(&quot; &quot;);</span>
<span class="fc" id="L1360">        sb.append(getFacade().getName(cls));</span>

        // add base class/interface
<span class="fc" id="L1363">        String baseClass =</span>
<span class="fc" id="L1364">            generateGeneralization(getFacade().getGeneralizations(cls));</span>
<span class="fc bfc" id="L1365" title="All 2 branches covered.">        if (!baseClass.equals (&quot;&quot;)) {</span>
<span class="fc" id="L1366">            sb.append (&quot; : &quot;)</span>
<span class="fc" id="L1367">                .append (baseClass);</span>
<span class="fc" id="L1368">            hasBaseClass = true;</span>
        }

        // add implemented interfaces, if needed (uml: realizations)
<span class="pc bpc" id="L1372" title="1 of 2 branches missed.">        if (getFacade().isAClass(cls)) {</span>
<span class="fc" id="L1373">            String interfaces = generateSpecification(cls);</span>
<span class="fc bfc" id="L1374" title="All 2 branches covered.">            if (!interfaces.equals (&quot;&quot;)) {</span>
<span class="pc bpc" id="L1375" title="1 of 2 branches missed.">                if (!hasBaseClass) sb.append (&quot; : &quot;);</span>
<span class="nc" id="L1376">                else sb.append (&quot;, &quot;);</span>
<span class="fc" id="L1377">                sb.append (interfaces);</span>
            }
        }
<span class="fc" id="L1380">        return sb;</span>
    }

    private StringBuffer generateClassifierEnd(Object cls) {
<span class="fc" id="L1384">        StringBuffer sb = new StringBuffer();</span>
<span class="pc bpc" id="L1385" title="3 of 4 branches missed.">        if (getFacade().isAClass(cls) || getFacade().isAInterface(cls)) {</span>
<span class="pc bpc" id="L1386" title="3 of 4 branches missed.">            if ((verboseDocs) &amp;&amp; (generatorPass != SOURCE_PASS)) {</span>
<span class="nc" id="L1387">                String classifierkeyword = null;</span>
<span class="nc bnc" id="L1388" title="All 2 branches missed.">                if (getFacade().isAClass(cls)) {</span>
<span class="nc" id="L1389">                    classifierkeyword = &quot;class&quot;;</span>
                } else {
<span class="nc" id="L1391">                    classifierkeyword = &quot;class&quot;;</span>
                }
<span class="nc" id="L1393">                sb.append(LINE_SEPARATOR)</span>
<span class="nc" id="L1394">                    .append(&quot;//end of &quot;)</span>
<span class="nc" id="L1395">                        .append(classifierkeyword)</span>
<span class="nc" id="L1396">                            .append(&quot; &quot;).append(getFacade().getName(cls))</span>
<span class="nc" id="L1397">                                .append(LINE_SEPARATOR);</span>
            }
<span class="fc bfc" id="L1399" title="All 2 branches covered.">            if (generatorPass != SOURCE_PASS)</span>
<span class="fc" id="L1400">                sb.append(&quot;};&quot;).append(LINE_SEPARATOR);</span>
        }
<span class="fc" id="L1402">        return sb;</span>
    }

    /**
     * Generate three parts under public, protected and private visibility,
     * adding the visibility keywords on top of each part. 
     * @param parts the parts to output
     * @return the composed parts
     */
    private String generateAllParts(StringBuffer[] parts) {
<span class="fc" id="L1412">        StringBuffer sb = new StringBuffer();</span>
        // generate all parts in order: public, protected, private
<span class="fc bfc" id="L1414" title="All 2 branches covered.">        for (int i = 0; i &lt; ALL_PARTS.length; i++) {</span>
<span class="fc bfc" id="L1415" title="All 2 branches covered.">            if (parts[i].toString().trim().length() &gt; 0) {</span>
<span class="fc bfc" id="L1416" title="All 2 branches covered.">                if (generatorPass != SOURCE_PASS) {</span>
<span class="pc bpc" id="L1417" title="1 of 2 branches missed.">                    if (i != 0) sb.append(LINE_SEPARATOR);</span>
<span class="fc" id="L1418">                    sb.append(' ').append(PART_NAME[i]).append(':');</span>
<span class="fc" id="L1419">                    sb.append(LINE_SEPARATOR);</span>
                }
<span class="fc" id="L1421">                sb.append(parts[i]);</span>
            }
        }
<span class="fc" id="L1424">        return sb.toString();</span>
    }
    
    private int getVisibilityPart(Object o) {
<span class="pc bpc" id="L1428" title="1 of 2 branches missed.">        if (getFacade().isPublic(o)) {</span>
<span class="fc" id="L1429">            return PUBLIC_PART;</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">        } else if (getFacade().isProtected(o)) {</span>
<span class="nc" id="L1431">            return PROTECTED_PART;</span>
<span class="nc bnc" id="L1432" title="All 2 branches missed.">        } else if (getFacade().isPrivate(o)) {</span>
<span class="nc" id="L1433">            return PRIVATE_PART;</span>
        } else {
<span class="nc" id="L1435">            LOG.warning(getFacade().getName(o)</span>
                        + &quot; is not public, nor protected, &quot;
                        + &quot;nor private!!! (ignored)&quot;);
<span class="nc" id="L1438">            return -1;</span>
        }
    }
    
    /* Indent each line of the given string by n indent spaces.
     */
    private String indentString(String s, int n) {
<span class="fc" id="L1445">        String ind = new String();</span>
<span class="fc bfc" id="L1446" title="All 2 branches covered.">        for (; n &gt; 0; n--)</span>
<span class="fc" id="L1447">            ind += indent;</span>
        // This works only with jdk 1.5: return s.replace(&quot;\n&quot;, &quot;\n&quot; + ind);
<span class="fc" id="L1449">        StringBuffer result = new StringBuffer();</span>
        // FIXME: replace hard-coded '\n' with LINE_SEPARATOR
<span class="fc bfc" id="L1451" title="All 2 branches covered.">        for (int i = s.indexOf('\n'); i != -1; i = s.indexOf('\n')) {</span>
<span class="fc" id="L1452">            result.append(ind).append(s.substring(0, i + 1));</span>
<span class="fc" id="L1453">            s = s.substring(i + 1);</span>
        }
<span class="pc bpc" id="L1455" title="1 of 2 branches missed.">        if (s.length() &gt; 0) {</span>
<span class="nc" id="L1456">            result.append(ind).append(s);</span>
        }
<span class="fc" id="L1458">        return result.toString();</span>
    }

    /*
     * Generates code for a classifier, for classes and interfaces only
     * at the moment.
     */
    public String generateClassifier(Object cls) {
        // If we're in the notation pane, do a special trick
        // to show both header and source
<span class="pc bpc" id="L1468" title="1 of 4 branches missed.">        if (generatorPass == NONE_PASS &amp;&amp; (getFacade().isAClass(cls) </span>
<span class="nc bnc" id="L1469" title="All 2 branches missed.">                || getFacade().isAInterface(cls))) {</span>
            // for inner classes, show source of top level class
            // TODO: don't know if this is the best thing to do
<span class="pc bpc" id="L1472" title="1 of 2 branches missed.">            while (isAInnerClass(cls)) {</span>
<span class="nc" id="L1473">                cls = getFacade().getNamespace(cls);</span>
            }
<span class="fc" id="L1475">            StringBuffer sb = new StringBuffer();</span>
<span class="fc" id="L1476">            String name = getFacade().getName(cls);</span>
<span class="fc" id="L1477">            sb.append(&quot;// &quot;).append(name).append(&quot;.h&quot;);</span>
<span class="fc" id="L1478">            sb.append(LINE_SEPARATOR);</span>
<span class="fc" id="L1479">            sb.append(generateH(cls));</span>
<span class="pc bpc" id="L1480" title="1 of 2 branches missed.">            if (getFacade().isAClass(cls)) {</span>
<span class="fc" id="L1481">                sb.append(LINE_SEPARATOR);</span>
<span class="fc" id="L1482">                sb.append(&quot;// &quot;).append(name).append(&quot;.cpp&quot;);</span>
<span class="fc" id="L1483">                sb.append(LINE_SEPARATOR);</span>
<span class="fc" id="L1484">                sb.append(generateCpp(cls));</span>
            }
<span class="fc" id="L1486">            return sb.toString();</span>
        }
        
<span class="fc" id="L1489">        StringBuffer returnValue = new StringBuffer();</span>
<span class="fc" id="L1490">        StringBuffer start = generateClassifierStart(cls);</span>
<span class="pc bpc" id="L1491" title="4 of 6 branches missed.">        if (((start != null) &amp;&amp; (start.length() &gt; 0))</span>
            || (generatorPass == SOURCE_PASS)) {
<span class="fc" id="L1493">            StringBuffer typedefs = generateGlobalTypedefs(cls);</span>
<span class="fc" id="L1494">            StringBuffer body = generateClassifierBody(cls);</span>
<span class="fc" id="L1495">            StringBuffer end = generateClassifierEnd(cls);</span>
<span class="pc bpc" id="L1496" title="1 of 2 branches missed.">            returnValue.append((typedefs != null) ? typedefs.toString() : &quot;&quot;);</span>
<span class="fc" id="L1497">            returnValue.append(start);</span>
<span class="pc bpc" id="L1498" title="1 of 4 branches missed.">            if ((body != null) &amp;&amp; (body.length() &gt; 0)) {</span>
<span class="fc" id="L1499">                returnValue.append(LINE_SEPARATOR);</span>
<span class="fc" id="L1500">                returnValue.append(body);</span>
<span class="pc bpc" id="L1501" title="1 of 2 branches missed.">                if (lfBeforeCurly) {</span>
<span class="nc" id="L1502">                    returnValue.append(LINE_SEPARATOR);</span>
                }
            }
<span class="pc bpc" id="L1505" title="1 of 2 branches missed.">            returnValue.append((end != null) ? end.toString() : &quot;&quot;);</span>
        }
<span class="fc" id="L1507">        return returnValue.toString();</span>
    }

    /** 2002-12-12 Achim Spangler
     * generate global typedefs
     */
    private StringBuffer generateGlobalTypedefs(Object cls) {
<span class="fc" id="L1514">        StringBuffer sb = new StringBuffer();</span>
<span class="pc bpc" id="L1515" title="3 of 4 branches missed.">        if (getFacade().isAClass(cls) || getFacade().isAInstance(cls)) {</span>
            // add typedefs
<span class="fc bfc" id="L1517" title="All 2 branches covered.">            if (generatorPass == HEADER_PASS) {</span>
<span class="fc" id="L1518">                Collection globalTypedefStatements =</span>
<span class="fc" id="L1519">                    findTagValues(cls, &quot;typedef_global_header&quot;);</span>
<span class="pc bpc" id="L1520" title="1 of 2 branches missed.">                if (!globalTypedefStatements.isEmpty()) {</span>
<span class="nc" id="L1521">                    sb.append(&quot;// global type definitions for header defined &quot;</span>
                              + &quot;by Tag entries in ArgoUML&quot;);
<span class="nc" id="L1523">                    sb.append(LINE_SEPARATOR);</span>
<span class="nc" id="L1524">                    sb.append(&quot;// Result: typedef &lt;typedef_global_header&gt; &quot;</span>
                              + &quot;&lt;tag_value&gt;;&quot;);
<span class="nc" id="L1526">                    sb.append(LINE_SEPARATOR);</span>
<span class="nc" id="L1527">                    Iterator typedefEnum =</span>
<span class="nc" id="L1528">                        globalTypedefStatements.iterator();</span>
<span class="nc bnc" id="L1529" title="All 2 branches missed.">                    while (typedefEnum.hasNext()) {</span>
<span class="nc" id="L1530">                        sb.append(&quot;typedef &quot;).append(typedefEnum.next());</span>
<span class="nc" id="L1531">                        sb.append(&quot;;&quot;).append(LINE_SEPARATOR);</span>
                    }
                }
<span class="fc" id="L1534">            }</span>
            else {
<span class="fc" id="L1536">                Collection globalTypedefStatements =</span>
<span class="fc" id="L1537">                    findTagValues(cls, &quot;typedef_global_source&quot;);</span>
<span class="pc bpc" id="L1538" title="1 of 2 branches missed.">                if (!globalTypedefStatements.isEmpty()) {</span>
<span class="nc" id="L1539">                    sb.append(&quot;// global type definitions for class &quot;</span>
                            + &quot;implementation in source file defined by Tag &quot;
                            + &quot;entries in ArgoUML&quot;);
<span class="nc" id="L1542">                    sb.append(LINE_SEPARATOR);</span>
<span class="nc" id="L1543">                    sb.append(&quot;// Result: typedef &lt;typedef_global_source&gt; &quot;</span>
                            + &quot;&lt;tag_value&gt;;&quot;);
<span class="nc" id="L1545">                    sb.append(LINE_SEPARATOR);</span>
<span class="nc" id="L1546">                    Iterator typedefEnum = globalTypedefStatements.iterator();</span>
<span class="nc bnc" id="L1547" title="All 2 branches missed.">                    while (typedefEnum.hasNext()) {</span>
<span class="nc" id="L1548">                        sb.append(&quot;typedef &quot;).append(typedefEnum.next());</span>
<span class="nc" id="L1549">                        sb.append(&quot;;&quot;).append(LINE_SEPARATOR);</span>
                    }
                }
            }
        }
<span class="fc" id="L1554">        return sb;</span>
    }

    /**
     * Generates the attributes of the body of a class or interface.
     * @param cls
     * @param sb Where to put the result.
     */
    private void generateClassifierBodyAttributes(Object cls,
            StringBuffer sb) {
<span class="fc" id="L1564">        Collection attrs = getFacade().getAttributes(cls);</span>
<span class="pc bpc" id="L1565" title="3 of 4 branches missed.">        if (attrs.isEmpty() || (generatorPass != HEADER_PASS)) {</span>
<span class="fc" id="L1566">            return;</span>
        }
<span class="nc" id="L1568">        String tv = null; // helper for tagged values</span>
<span class="nc" id="L1569">        sb.append(LINE_SEPARATOR);</span>
<span class="nc bnc" id="L1570" title="All 4 branches missed.">        if (verboseDocs &amp;&amp; getFacade().isAClass(cls)) {</span>
<span class="nc" id="L1571">            sb.append(indent).append(&quot;// Attributes&quot;).append(LINE_SEPARATOR);</span>
        }

        // generate attributes in order public, protected, private
<span class="nc" id="L1575">        StringBuffer part[] = new StringBuffer[ALL_PARTS.length];</span>
<span class="nc bnc" id="L1576" title="All 2 branches missed.">        for (int i = 0; i &lt; part.length; i++)</span>
<span class="nc" id="L1577">            part[i] = new StringBuffer(80);</span>
        
<span class="nc" id="L1579">        Iterator attrIter = attrs.iterator();</span>
<span class="nc bnc" id="L1580" title="All 2 branches missed.">        while (attrIter.hasNext()) {</span>
<span class="nc" id="L1581">            Object attr = attrIter.next();</span>
<span class="nc" id="L1582">            int i = getVisibilityPart(attr);</span>

<span class="nc" id="L1584">            part[i].append(indent).append(generateAttribute(attr, false));</span>

<span class="nc" id="L1586">            tv = generateTaggedValues(attr, ALL_BUT_DOC_TAGS);</span>
<span class="nc bnc" id="L1587" title="All 4 branches missed.">            if (tv != null &amp;&amp; tv.length() &gt; 0) {</span>
<span class="nc" id="L1588">                part[i].append(indent).append(tv);</span>
            }
<span class="nc" id="L1590">        }</span>
<span class="nc" id="L1591">        sb.append(generateAllParts(part));</span>
<span class="nc" id="L1592">    }</span>

    /**
     * Generates the association ends of the body of a class or interface.
     * @param cls The classifier to generate.
     * @param sb Where to put the result.
     */
    private void generateClassifierBodyAssociations(Object cls,
            StringBuffer sb) {

<span class="fc bfc" id="L1602" title="All 2 branches covered.">        if (generatorPass == SOURCE_PASS)</span>
<span class="fc" id="L1603">            return;</span>

<span class="fc" id="L1605">        Collection ends = getFacade().getAssociationEnds(cls);</span>
<span class="fc bfc" id="L1606" title="All 2 branches covered.">        if (!ends.isEmpty()) {</span>

<span class="fc" id="L1608">            sb.append(LINE_SEPARATOR);</span>
<span class="pc bpc" id="L1609" title="3 of 4 branches missed.">            if (verboseDocs &amp;&amp; getFacade().isAClass(cls)) {</span>
<span class="nc" id="L1610">                sb.append(indent).append(&quot;// Associations&quot;).append(</span>
                        LINE_SEPARATOR);
            }

<span class="fc" id="L1614">            StringBuffer part[] = new StringBuffer[3];</span>
<span class="fc bfc" id="L1615" title="All 2 branches covered.">            for (int i = 0; i &lt; ALL_PARTS.length; i++)</span>
<span class="fc" id="L1616">                part[i] = new StringBuffer(80);</span>
            
<span class="fc" id="L1618">            Iterator endEnum = ends.iterator();</span>
<span class="fc bfc" id="L1619" title="All 2 branches covered.">            while (endEnum.hasNext()) {</span>
<span class="fc" id="L1620">                Object ae = endEnum.next();</span>
<span class="fc" id="L1621">                Object a = getFacade().getAssociation(ae);</span>
<span class="fc" id="L1622">                AssociationEndHandler aeHandler = new AssociationEndHandler(</span>
                        ae);
                try {
<span class="fc" id="L1625">                    aeHandler.pre();</span>
<span class="fc" id="L1626">                    generateAssociationFrom(a, ae, part);</span>
                } finally {
<span class="fc" id="L1628">                    aeHandler.post();</span>
                }
<span class="fc" id="L1630">            }</span>
<span class="fc" id="L1631">            sb.append(generateAllParts(part));</span>
        }
        // if this is an association class, generate attributes for
        // all the AssociationEnds
<span class="pc bpc" id="L1635" title="1 of 2 branches missed.">        if (getFacade().isAAssociationClass(cls)) {</span>
<span class="nc bnc" id="L1636" title="All 2 branches missed.">            if (verboseDocs) {</span>
<span class="nc" id="L1637">                sb.append(LINE_SEPARATOR).append(indent);</span>
<span class="nc" id="L1638">                sb.append(&quot;// AssociationClass associated classes&quot;);</span>
            }
            // make all ends public... does it make sense?
            // should we declare friend all the associated and make
            // these protected? (private is too restrictive anyway, IMHO)
            // TODO: make it configurable, with a tag 
<span class="nc" id="L1644">            sb.append(LINE_SEPARATOR).append(&quot; public:&quot;).append(LINE_SEPARATOR);</span>
<span class="nc" id="L1645">            ends = getFacade().getConnections(cls);</span>
<span class="nc" id="L1646">            Iterator iter = ends.iterator();</span>
<span class="nc bnc" id="L1647" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
<span class="nc" id="L1648">                Object ae = iter.next();</span>
<span class="nc" id="L1649">                sb.append(LINE_SEPARATOR);</span>
<span class="nc" id="L1650">                String comment = generateConstraintEnrichedDocComment(cls, ae);</span>
<span class="nc bnc" id="L1651" title="All 2 branches missed.">                if (comment.length() &gt; 0)</span>
<span class="nc" id="L1652">                    sb.append(comment).append(indent);</span>

<span class="nc" id="L1654">                String n = getFacade().getName(ae);</span>
                String name;
<span class="nc" id="L1656">                Object type = getFacade().getType(ae);</span>

<span class="nc bnc" id="L1658" title="All 4 branches missed.">                if (n != null &amp;&amp; n.length() &gt; 0) {</span>
<span class="nc" id="L1659">                    name = n;</span>
                } else {
<span class="nc" id="L1661">                    name = &quot;my&quot; + generateClassifierRef(type);</span>
                }

<span class="nc" id="L1664">                sb.append(generateNameWithPkgSelection(type));</span>
<span class="nc" id="L1665">                sb.append(generateAttributeParameterModifier(ae));</span>
<span class="nc" id="L1666">                sb.append(&quot; &quot;).append(name);</span>
<span class="nc" id="L1667">                sb.append(&quot;;&quot;).append(LINE_SEPARATOR);</span>

                // add the type of the association end in the dependency list
<span class="nc bnc" id="L1670" title="All 2 branches missed.">                addDependency(type, !checkIncludeNeeded4Element(type));</span>

<span class="nc" id="L1672">                String tv = generateTaggedValues(ae, ALL_BUT_DOC_TAGS);</span>
<span class="nc bnc" id="L1673" title="All 4 branches missed.">                if (tv != null &amp;&amp; tv.length() &gt; 0) {</span>
<span class="nc" id="L1674">                    sb.append(indent).append(tv);</span>
                }
<span class="nc" id="L1676">            }</span>
        }
<span class="fc" id="L1678">    }</span>

    /**
     * Check whether an operation body shall be generated within the actual
     * pass. This is normally done during the implementation path.
     * But if the Tag &quot;inline&quot; exists, the method body shall be defined as
     * as inline in header file
     * @return true -&gt; generate body in actual path
     */
    private boolean checkGenerateOperationBody(Object op) {
<span class="fc bfc" id="L1688" title="All 2 branches covered.">        boolean result = !((generatorPass == HEADER_PASS)</span>
<span class="pc bpc" id="L1689" title="1 of 2 branches missed.">            || (getFacade().isAbstract(op))</span>
<span class="pc bpc" id="L1690" title="1 of 2 branches missed.">                || (getFacade().isAInterface(getFacade().getOwner(op))));</span>

        // if this operation has Tag &quot;inline&quot; the method shall be
        // generated in header
<span class="fc" id="L1694">        Inline inlineStyle = Inline.getInlineOperationModifierType(op);</span>
<span class="fc bfc" id="L1695" title="All 2 branches covered.">        if (generatorPass == HEADER_PASS) {</span>
<span class="fc" id="L1696">            result = inlineStyle.isMethodBodyInsideClass();</span>
<span class="pc bpc" id="L1697" title="1 of 2 branches missed.">        } else if (generatorPass == NONE_PASS) {</span>
<span class="nc" id="L1698">            result = inlineStyle.isMethodBodyOutsideClass();</span>
        }
        
<span class="fc" id="L1701">        return result;</span>
    }

    /** 2002-12-13 Achim Spangler
     * generate a single set function for a given attribute and StringBuffer
     */
    private void generateSingleAttributeSet(Object attr, StringBuffer sb) {
<span class="nc bnc" id="L1708" title="All 2 branches missed.">        if (getFacade().getType(attr) == null) {</span>
<span class="nc" id="L1709">            return;</span>
        }
        // generate for attributes with class-type:
        // &quot;indent void set_&lt;name&gt;( const &lt;type&gt; &amp;value ) { &lt;name&gt; = value; };&quot;
        // generate for other (small) data types:
        // &quot;indent void set_&lt;name&gt;( &lt;type&gt; value ) { &lt;name&gt; = value; };&quot;
        // generate: &quot;indent void set_&lt;name&gt;( &quot;
<span class="nc" id="L1716">        sb.append(LINE_SEPARATOR).append(indent);</span>
<span class="nc" id="L1717">        sb.append(&quot;/** simple access function to set the attribute &quot;);</span>
<span class="nc" id="L1718">        sb.append(getFacade().getName(attr));</span>
<span class="nc" id="L1719">        sb.append(&quot; by function&quot;).append(LINE_SEPARATOR).append(indent);</span>
<span class="nc" id="L1720">        sb.append(&quot;  * @param value value to set for the attribute &quot;);</span>
<span class="nc" id="L1721">        sb.append(getFacade().getName(attr)).append(LINE_SEPARATOR);</span>
<span class="nc" id="L1722">        sb.append(indent).append(&quot;  */&quot;).append(LINE_SEPARATOR);</span>
<span class="nc" id="L1723">        sb.append(indent);</span>
<span class="nc" id="L1724">        sb.append(&quot;void set_&quot;).append(getFacade().getName(attr))</span>
<span class="nc" id="L1725">            .append(&quot;( &quot;);</span>
<span class="nc" id="L1726">        String modifier = generateAttributeParameterModifier(attr);</span>
<span class="nc bnc" id="L1727" title="All 4 branches missed.">        if (modifier != null &amp;&amp; modifier.length() &gt; 0) {</span>
            // generate: &quot;const &lt;type&gt; &lt;modifier&gt;value&quot;
<span class="nc bnc" id="L1729" title="All 2 branches missed.">            if (modifier.equals(&quot;&amp;&quot;)) sb.append(&quot;const &quot;);</span>
<span class="nc" id="L1730">            sb.append(generateClassifierRef(getFacade().getType(attr)))</span>
<span class="nc" id="L1731">                .append(' ').append(modifier).append(&quot;value&quot;);</span>
<span class="nc bnc" id="L1732" title="All 2 branches missed.">        } else if (getFacade().isAClass(getFacade().getType(attr))) {</span>
            // generate: &quot;const &lt;type&gt; &amp;value&quot;
<span class="nc" id="L1734">            sb.append(&quot;const &quot;);</span>
<span class="nc" id="L1735">            sb.append(generateClassifierRef(getFacade().getType(attr)));</span>
<span class="nc" id="L1736">            sb.append(&quot; &amp;value&quot;);</span>
        } else {
            // generate: &quot;&lt;type&gt; value&quot;
<span class="nc" id="L1739">            sb.append(generateClassifierRef(getFacade().getType(attr)))</span>
<span class="nc" id="L1740">                .append(&quot; value&quot;);</span>
        }
        // generate: &quot; ) { &lt;name&gt; = value; };&quot;
<span class="nc" id="L1743">        sb.append(&quot; ) { &quot;).append(getFacade().getName(attr));</span>
<span class="nc" id="L1744">        sb.append(&quot; = value; };&quot;).append(LINE_SEPARATOR);</span>
<span class="nc" id="L1745">    }</span>

    /** 2002-12-13 Achim Spangler
     * generate a single get function for a given attribute and StringBuffer
     */
    private void generateSingleAttributeGet(Object attr, StringBuffer sb) {
<span class="nc bnc" id="L1751" title="All 2 branches missed.">        if (getFacade().getType(attr) == null) return;</span>
        // generate for attributes with class-type:
        // &quot;const &lt;type&gt;&amp; get_&lt;name&gt;( void ) { return &lt;name&gt;; };&quot;
        // generate for other (small) data types
        // &quot;&lt;type&gt; get_&lt;name&gt;( void ) { return &lt;name&gt;; };&quot;
        // generate: &quot;indent&quot;
<span class="nc" id="L1757">        sb.append(LINE_SEPARATOR).append(indent);</span>
<span class="nc" id="L1758">        sb.append(&quot;/** simple access function to get the attribute &quot;);</span>
<span class="nc" id="L1759">        sb.append(getFacade().getName(attr));</span>
<span class="nc" id="L1760">        sb.append(&quot; by function */&quot;).append(LINE_SEPARATOR).append(indent);</span>
<span class="nc" id="L1761">        String modifier = generateAttributeParameterModifier(attr);</span>
<span class="nc bnc" id="L1762" title="All 4 branches missed.">        if (modifier != null &amp;&amp; modifier.length() &gt; 0) {</span>
            // generate: &quot;const &lt;type&gt;&lt;modifier&gt;&quot;
<span class="nc" id="L1764">            sb.append(&quot;const &quot;);</span>
<span class="nc" id="L1765">            sb.append(generateClassifierRef(getFacade().getType(attr)));</span>
<span class="nc" id="L1766">            sb.append(modifier);</span>
<span class="nc bnc" id="L1767" title="All 2 branches missed.">        } else if (getFacade().isAClass(getFacade().getType(attr))) {</span>
            // generate: &quot;const &lt;type&gt;&amp;&quot;
<span class="nc" id="L1769">            sb.append(&quot;const &quot;);</span>
<span class="nc" id="L1770">            sb.append(generateClassifierRef(getFacade().getType(attr)));</span>
<span class="nc" id="L1771">            sb.append(&quot;&amp;&quot;);</span>
        } else {
            // generate: &quot;&lt;type&gt;&quot;
<span class="nc" id="L1774">            sb.append(generateClassifierRef(getFacade().getType(attr)));</span>
        }
        // generate: &quot; get_&lt;name&gt;( void ) const { return &lt;name&gt;; };&quot;
<span class="nc" id="L1777">        sb.append(&quot; get_&quot;).append(getFacade().getName(attr));</span>
<span class="nc" id="L1778">        sb.append(&quot;( void ) const { return &quot;)</span>
<span class="nc" id="L1779">            .append(getFacade().getName(attr));</span>
<span class="nc" id="L1780">        sb.append(&quot;; };&quot;).append(LINE_SEPARATOR);</span>
<span class="nc" id="L1781">    }</span>

    /**
     * Generates the attributes of the body of a class or interface.
     * @param cls
     */
    private void generateClassifierBodyTaggedAccess4Attributes(
            Object cls,
            StringBuffer funcPrivate,
            StringBuffer funcProtected,
            StringBuffer funcPublic) {
<span class="fc" id="L1792">        Collection strs = getFacade().getAttributes(cls);</span>
<span class="pc bpc" id="L1793" title="3 of 4 branches missed.">        if (strs.isEmpty() || (generatorPass != HEADER_PASS)) {</span>
<span class="fc" id="L1794">            return;</span>
        }
<span class="nc" id="L1796">        String accessTag = null;</span>

<span class="nc" id="L1798">        Iterator strEnum = strs.iterator();</span>
<span class="nc bnc" id="L1799" title="All 2 branches missed.">        while (strEnum.hasNext()) {</span>
<span class="nc" id="L1800">            Object attr = strEnum.next();</span>
<span class="nc" id="L1801">            accessTag = getFacade().getTaggedValueValue(attr, </span>
                    TV_NAME_SET);
<span class="nc bnc" id="L1803" title="All 4 branches missed.">            if (accessTag != null &amp;&amp; accessTag.length() &gt; 0) {</span>
<span class="nc bnc" id="L1804" title="All 2 branches missed.">                if (accessTag.indexOf(&quot;public&quot;) != -1) {</span>
<span class="nc" id="L1805">                    generateSingleAttributeSet(attr, funcPublic);</span>
                }
<span class="nc bnc" id="L1807" title="All 2 branches missed.">                if (accessTag.indexOf(&quot;protected&quot;) != -1) {</span>
<span class="nc" id="L1808">                    generateSingleAttributeSet(attr, funcProtected);</span>
                }
<span class="nc bnc" id="L1810" title="All 2 branches missed.">                if (accessTag.indexOf(&quot;private&quot;) != -1) {</span>
<span class="nc" id="L1811">                    generateSingleAttributeSet(attr, funcPrivate);</span>
                }
            }

<span class="nc" id="L1815">            accessTag = getFacade().getTaggedValueValue(attr, </span>
                    TV_NAME_GET);
<span class="nc bnc" id="L1817" title="All 4 branches missed.">            if (accessTag != null &amp;&amp; accessTag.length() &gt; 0) {</span>
<span class="nc bnc" id="L1818" title="All 2 branches missed.">                if (accessTag.indexOf(&quot;public&quot;) != -1) {</span>
<span class="nc" id="L1819">                    generateSingleAttributeGet(attr, funcPublic);</span>
                }
<span class="nc bnc" id="L1821" title="All 2 branches missed.">                if (accessTag.indexOf(&quot;protected&quot;) != -1) {</span>
<span class="nc" id="L1822">                    generateSingleAttributeGet(attr, funcProtected);</span>
                }
<span class="nc bnc" id="L1824" title="All 2 branches missed.">                if (accessTag.indexOf(&quot;private&quot;) != -1) {</span>
<span class="nc" id="L1825">                    generateSingleAttributeGet(attr, funcPrivate);</span>
                }
            }
<span class="nc" id="L1828">        }</span>
<span class="nc" id="L1829">    }</span>

    /**
     * Generates the association ends of the body of a class or interface.
     * @param cls
     * @param sb Where to put the result.
     */
    private void generateClassifierBodyOperations(Object cls,
            StringBuffer sb) {
<span class="fc" id="L1838">        Collection behs = getFacade().getOperations(cls);</span>
<span class="fc bfc" id="L1839" title="All 2 branches covered.">        if (behs.isEmpty()) return;</span>
<span class="fc" id="L1840">        sb.append(LINE_SEPARATOR);</span>
<span class="pc bpc" id="L1841" title="1 of 2 branches missed.">        if (verboseDocs) {</span>
<span class="nc" id="L1842">            sb.append(indent).append(&quot;// Operations&quot;).append(LINE_SEPARATOR);</span>
        }

        // generate tag controlled access functions for attributes
<span class="fc" id="L1846">        StringBuffer[] funcs = new StringBuffer[3]; </span>
<span class="fc" id="L1847">        funcs[0] = new StringBuffer(80);</span>
<span class="fc" id="L1848">        funcs[1] = new StringBuffer(80);</span>
<span class="fc" id="L1849">        funcs[2] = new StringBuffer(80);</span>
<span class="fc" id="L1850">        generateClassifierBodyTaggedAccess4Attributes(cls, funcs[PRIVATE_PART],</span>
                                                      funcs[PROTECTED_PART],
                                                      funcs[PUBLIC_PART]);

<span class="fc" id="L1854">        Iterator behEnum = behs.iterator();</span>
<span class="fc bfc" id="L1855" title="All 2 branches covered.">        while (behEnum.hasNext()) {</span>
<span class="fc" id="L1856">            Object bf = behEnum.next();</span>
<span class="fc" id="L1857">            StringBuffer tb = null;</span>

<span class="fc" id="L1859">            int p = getVisibilityPart(bf);</span>
<span class="pc bpc" id="L1860" title="1 of 2 branches missed.">            if (p &lt; 0) continue;</span>
<span class="fc" id="L1861">            tb = funcs[p];</span>

<span class="fc" id="L1863">            boolean mustGenBody = checkGenerateOperationBody(bf);</span>
<span class="pc bpc" id="L1864" title="2 of 6 branches missed.">            if (tb != null &amp;&amp; ((generatorPass == HEADER_PASS) || mustGenBody)) {</span>
<span class="fc" id="L1865">                tb.append(LINE_SEPARATOR);</span>
<span class="fc" id="L1866">                tb.append(generateOperation(bf, false));</span>
                
                // helper for tagged values
<span class="fc" id="L1869">                String tv = generateTaggedValues(bf, ALL_BUT_DOC_TAGS);</span>
                
<span class="pc bpc" id="L1871" title="1 of 4 branches missed.">                if (mustGenBody &amp;&amp; (getFacade().isAClass(cls))</span>
<span class="pc bpc" id="L1872" title="1 of 2 branches missed.">                        &amp;&amp; (getFacade().isAOperation(bf))</span>
<span class="pc bpc" id="L1873" title="1 of 2 branches missed.">                        &amp;&amp; (!getFacade().isAbstract(bf))) {</span>
                    // there is no ReturnType in behavioral feature (uml)
<span class="fc" id="L1875">                    tb.append(LINE_SEPARATOR).append(generateMethodBody(bf));</span>
                } else {
<span class="fc" id="L1877">                    tb.append(&quot;;&quot;).append(LINE_SEPARATOR);</span>
<span class="fc bfc" id="L1878" title="All 2 branches covered.">                    if (tv.length() &gt; 0) {</span>
<span class="fc" id="L1879">                        tb.append(indent).append(tv).append(LINE_SEPARATOR);</span>
                    }
                }
            }
<span class="fc" id="L1883">        } // end loop through all operations</span>

<span class="fc" id="L1885">        sb.append(generateAllParts(funcs));</span>
<span class="fc" id="L1886">    }</span>

    /**
     * Generates the association ends of the body of a class or interface.
     * @param cls
     * @param sb Where to put the result.
     */
    private void generateClassifierBodyTypedefs(Object cls, StringBuffer sb) {
<span class="fc bfc" id="L1894" title="All 2 branches covered.">        if (generatorPass == HEADER_PASS) {</span>
<span class="fc" id="L1895">            Collection publicTypedefStatements =</span>
<span class="fc" id="L1896">                findTagValues(cls, TV_NAME_TYPEDEF_PUBLIC);</span>
<span class="fc" id="L1897">            Collection protectedTypedefStatements =</span>
<span class="fc" id="L1898">                findTagValues(cls, TV_NAME_TYPEDEF_PROTECTED);</span>
<span class="fc" id="L1899">            Collection privateTypedefStatements =</span>
<span class="fc" id="L1900">                findTagValues(cls, TV_NAME_TYPEDEF_PRIVATE);</span>
<span class="pc bpc" id="L1901" title="1 of 2 branches missed.">            if (!publicTypedefStatements.isEmpty()) {</span>
<span class="nc" id="L1902">                sb.append(LINE_SEPARATOR).append(&quot; public:&quot;)</span>
<span class="nc" id="L1903">                    .append(LINE_SEPARATOR).append(indent);</span>
<span class="nc" id="L1904">                sb.append(&quot;// public type definitions for header defined &quot;</span>
<span class="nc" id="L1905">                      + &quot;by Tag entries in ArgoUML&quot;).append(LINE_SEPARATOR);</span>
<span class="nc" id="L1906">                sb.append(indent);</span>
<span class="nc" id="L1907">                sb.append(&quot;// Result: typedef &lt;typedef_public&gt; &quot;</span>
<span class="nc" id="L1908">                      + &quot;&lt;tag_value&gt;;&quot;).append(LINE_SEPARATOR);</span>
<span class="nc" id="L1909">                Iterator typedefEnum = publicTypedefStatements.iterator();</span>

<span class="nc bnc" id="L1911" title="All 2 branches missed.">                while (typedefEnum.hasNext()) {</span>
<span class="nc" id="L1912">                    sb.append(indent).append(&quot;typedef &quot;);</span>
<span class="nc" id="L1913">                    sb.append(typedefEnum.next())</span>
<span class="nc" id="L1914">                        .append(&quot;;&quot;).append(LINE_SEPARATOR);</span>
                }
            }
<span class="pc bpc" id="L1917" title="1 of 2 branches missed.">            if (!protectedTypedefStatements.isEmpty()) {</span>
<span class="nc" id="L1918">                sb.append(LINE_SEPARATOR).append(&quot; protected:&quot;)</span>
<span class="nc" id="L1919">                    .append(LINE_SEPARATOR).append(indent);</span>
<span class="nc" id="L1920">                sb.append(&quot;// protected type definitions for header defined &quot;</span>
<span class="nc" id="L1921">                      + &quot;by Tag entries in ArgoUML&quot;).append(LINE_SEPARATOR);</span>
<span class="nc" id="L1922">                sb.append(indent);</span>
<span class="nc" id="L1923">                sb.append(&quot;// Result: typedef &lt;typedef_protected&gt; &quot;</span>
<span class="nc" id="L1924">                      + &quot;&lt;tag_value&gt;;&quot;).append(LINE_SEPARATOR);</span>
<span class="nc" id="L1925">                Iterator typedefEnum = protectedTypedefStatements.iterator();</span>

<span class="nc bnc" id="L1927" title="All 2 branches missed.">                while (typedefEnum.hasNext()) {</span>
<span class="nc" id="L1928">                    sb.append(indent).append(&quot;typedef &quot;);</span>
<span class="nc" id="L1929">                    sb.append(typedefEnum.next())</span>
<span class="nc" id="L1930">                        .append(&quot;;&quot;).append(LINE_SEPARATOR);</span>
                }
            }
<span class="pc bpc" id="L1933" title="1 of 2 branches missed.">            if (!privateTypedefStatements.isEmpty()) {</span>
<span class="nc" id="L1934">                sb.append(LINE_SEPARATOR).append(&quot; private:&quot;)</span>
<span class="nc" id="L1935">                    .append(LINE_SEPARATOR).append(indent);</span>
<span class="nc" id="L1936">                sb.append(&quot;// private type definitions for header defined &quot;</span>
<span class="nc" id="L1937">                      + &quot;by Tag entries in ArgoUML&quot;).append(LINE_SEPARATOR);</span>
<span class="nc" id="L1938">                sb.append(indent);</span>
<span class="nc" id="L1939">                sb.append(&quot;// Result: typedef &lt;typedef_private&gt; &quot;</span>
<span class="nc" id="L1940">                      + &quot;&lt;tag_value&gt;;&quot;).append(LINE_SEPARATOR);</span>
<span class="nc" id="L1941">                Iterator typedefEnum = privateTypedefStatements.iterator();</span>

<span class="nc bnc" id="L1943" title="All 2 branches missed.">                while (typedefEnum.hasNext()) {</span>
<span class="nc" id="L1944">                    sb.append(indent).append(&quot;typedef &quot;);</span>
<span class="nc" id="L1945">                    sb.append(typedefEnum.next()).append(&quot;;&quot;)</span>
<span class="nc" id="L1946">                        .append(LINE_SEPARATOR);</span>
                }
            }
        }
<span class="fc" id="L1950">    }</span>

    /**
     * Generates a virtual destructor when the classifier is an interface.
     * @param cls the classifier object
     * @param sb the buffer to where the generate code goes
     */
    private void generateClassifierDestructor(Object cls, StringBuffer sb) {
<span class="pc bpc" id="L1958" title="3 of 4 branches missed.">        if (getFacade().isAInterface(cls) </span>
                &amp;&amp; generatorPass == HEADER_PASS) {
<span class="nc" id="L1960">            sb.append(LINE_SEPARATOR).append(&quot;public:&quot;).append(LINE_SEPARATOR);</span>
<span class="nc" id="L1961">            sb.append(indent).append(&quot;// virtual destructor for interface &quot;)</span>
<span class="nc" id="L1962">                .append(LINE_SEPARATOR);</span>
<span class="nc" id="L1963">            sb.append(indent).append(&quot;virtual &quot;).append('~').append(</span>
<span class="nc" id="L1964">                getFacade().getName(cls)).append(&quot;() { }&quot;)</span>
<span class="nc" id="L1965">                    .append(LINE_SEPARATOR);</span>
        }
<span class="fc" id="L1967">    }</span>

    private void generateClassifierInnerClasses(Object cls, StringBuffer sb) {
<span class="fc" id="L1970">        StringBuffer part[] = new StringBuffer[ALL_PARTS.length];</span>
<span class="fc bfc" id="L1971" title="All 2 branches covered.">        for (int i = 0; i &lt; part.length; i++)</span>
<span class="fc" id="L1972">            part[i] = new StringBuffer(80);</span>

<span class="fc" id="L1974">        Collection inners = getFacade().getOwnedElements(cls);</span>
<span class="fc bfc" id="L1975" title="All 2 branches covered.">        for (Iterator it = inners.iterator(); it.hasNext();) {</span>
<span class="fc" id="L1976">            Object inner = it.next();</span>
<span class="pc bpc" id="L1977" title="1 of 2 branches missed.">            if (getFacade().isAClass(inner)</span>
<span class="nc bnc" id="L1978" title="All 2 branches missed.">                || getFacade().isAInterface(inner)) {</span>
<span class="fc" id="L1979">                String innerCode = generateClassifier(inner);</span>
<span class="fc" id="L1980">                int p = getVisibilityPart(inner);</span>
<span class="fc" id="L1981">                part[p].append(LINE_SEPARATOR);</span>
<span class="fc bfc" id="L1982" title="All 2 branches covered.">                if (generatorPass == HEADER_PASS) {</span>
<span class="fc" id="L1983">                    part[p].append(indentString(innerCode, 1));</span>
                } else {
<span class="fc" id="L1985">                    part[p].append(innerCode);</span>
                }
<span class="fc" id="L1987">                part[p].append(LINE_SEPARATOR);</span>
            }
<span class="fc" id="L1989">        }</span>
<span class="fc" id="L1990">        sb.append(generateAllParts(part));</span>
<span class="fc" id="L1991">    }</span>

    /**
     * Generates the body of a class or interface.
     * @param cls
     * @return a StringBuffer with the result.
     */
    private StringBuffer generateClassifierBody(Object cls) {
<span class="fc" id="L1999">        StringBuffer sb = new StringBuffer();</span>
<span class="pc bpc" id="L2000" title="3 of 4 branches missed.">        if (getFacade().isAClass(cls) || getFacade().isAInterface(cls))</span>
        { 
            // Inner classes
<span class="fc" id="L2003">            generateClassifierInnerClasses(cls, sb);</span>

            // add operations
            // TODO: constructors
<span class="fc" id="L2007">            generateClassifierBodyOperations(cls, sb);</span>

            // fixing issue #2587
<span class="fc" id="L2010">            generateClassifierDestructor(cls, sb);</span>

            // add attributes
<span class="fc" id="L2013">            generateClassifierBodyAttributes(cls, sb);</span>

            // add attributes implementing associations
<span class="fc" id="L2016">            generateClassifierBodyAssociations(cls, sb);</span>

            // add typedefs
<span class="fc" id="L2019">            generateClassifierBodyTypedefs(cls, sb);</span>
        }
<span class="fc" id="L2021">        return sb;</span>
    }

    /**
     * Generate the body of a method associated with the given
     * operation.  This assumes there's at most one method associated!
     *
     * If no method is associated with the operation, a default method
     * body will be generated.
     */
    private String generateMethodBody(Object op) {
<span class="pc bpc" id="L2032" title="1 of 2 branches missed.">        if (op != null) {</span>
<span class="fc" id="L2033">            StringBuffer sb = new StringBuffer(80);</span>
<span class="fc" id="L2034">            Collection methods = getFacade().getMethods(op);</span>
<span class="fc" id="L2035">            Iterator i = methods.iterator();</span>
<span class="fc" id="L2036">            Object method = null;</span>
<span class="fc" id="L2037">            boolean methodFound = false;</span>
<span class="fc" id="L2038">            String tv = generateTaggedValues(op, ALL_BUT_DOC_TAGS);</span>
            String operationIndent =
<span class="fc bfc" id="L2040" title="All 2 branches covered.">                (generatorPass == HEADER_PASS) ? indent : &quot;&quot;;</span>

            // append tags which are not Doc-Comments
<span class="fc bfc" id="L2043" title="All 2 branches covered.">            if (tv.length() &gt; 0) {</span>
<span class="fc" id="L2044">                sb.append(operationIndent).append(tv).append(LINE_SEPARATOR);</span>
            }

            // place the curly braces within the protected area, to
            // allow placement of preserved constructor initializers in
            // this area otherwise all possible constructor-attribute
            // initializers would have to be autogenerated with an
            // army of special tags
<span class="fc" id="L2052">            sb.append(generateSectionTop(op, operationIndent))</span>
<span class="fc" id="L2053">                .append(operationIndent).append(&quot;{&quot;).append(LINE_SEPARATOR);</span>

<span class="pc bpc" id="L2055" title="2 of 4 branches missed.">            while (i != null &amp;&amp; i.hasNext()) {</span>
<span class="nc" id="L2056">                method = i.next();</span>

<span class="nc bnc" id="L2058" title="All 2 branches missed.">                if (method != null) {</span>
<span class="nc bnc" id="L2059" title="All 4 branches missed.">                    if ((getFacade().getBody(method) != null)</span>
                            &amp;&amp; (!methodFound)) {
<span class="nc" id="L2061">                        Object body = getFacade().getBody(method);</span>
<span class="nc" id="L2062">                        sb.append(getFacade().getBody(body));</span>
<span class="nc" id="L2063">                        methodFound = true;</span>
<span class="nc" id="L2064">                        break;</span>
                    }
                }
            }

<span class="pc bpc" id="L2069" title="1 of 2 branches missed.">            if (!methodFound) {</span>
                // pick out return type as default method body
<span class="fc" id="L2071">                Collection returnParams = getCoreHelper()</span>
<span class="fc" id="L2072">                        .getReturnParameters(op);</span>
                Object rp;
<span class="pc bpc" id="L2074" title="1 of 2 branches missed.">                if (returnParams.size() == 0) {</span>
<span class="nc" id="L2075">                    rp = null;</span>
                } else {
<span class="fc" id="L2077">                    rp = returnParams.iterator().next();</span>
                } 
<span class="pc bpc" id="L2079" title="1 of 2 branches missed.">                if (returnParams.size() &gt; 1)  {</span>
<span class="nc" id="L2080">                    LOG.warning(&quot;C++ generator only handles one return&quot;</span>
<span class="nc" id="L2081">                                + &quot; parameter - Found &quot; + returnParams.size()</span>
<span class="nc" id="L2082">                                + &quot; for &quot; + getFacade().getName(op));</span>
                }
<span class="pc bpc" id="L2084" title="1 of 2 branches missed.">                if (rp != null) {</span>
<span class="fc" id="L2085">                    Object returnType = getFacade().getType(rp);</span>
<span class="fc" id="L2086">                    sb.append(generateDefaultReturnStatement(returnType));</span>
                }
            }
<span class="fc" id="L2089">            sb.append(operationIndent).append(&quot;}&quot;).append(LINE_SEPARATOR)</span>
<span class="fc" id="L2090">                .append(generateSectionBottom(op, operationIndent));</span>
<span class="fc" id="L2091">            return sb.toString();</span>
        }
<span class="nc" id="L2093">        return generateDefaultReturnStatement (null);</span>
    }


    private String generateSectionTop(Object op, String localIndent) {
<span class="fc" id="L2098">        String id = UUIDHelper.getUUID(op);</span>
<span class="fc" id="L2099">        return Section.generateTop(id, localIndent);</span>
    }

    private String generateSectionBottom(Object op, String localIndent) {
<span class="fc" id="L2103">        String id = UUIDHelper.getUUID(op);</span>
<span class="fc" id="L2104">        return Section.generateBottom(id, localIndent);</span>
    }

    private String generateDefaultReturnStatement(Object cls) {
<span class="pc bpc" id="L2108" title="1 of 2 branches missed.">        if (cls == null) return &quot;&quot;;</span>

<span class="fc" id="L2110">        String clsName = getFacade().getName(cls);</span>
<span class="fc" id="L2111">        String res = null;</span>
<span class="fc bfc" id="L2112" title="All 2 branches covered.">        if (clsName.equals(&quot;void&quot;)) res = &quot;&quot;;</span>
<span class="pc bpc" id="L2113" title="1 of 2 branches missed.">        else if (clsName.equals(&quot;char&quot;)) res = &quot;return 'x';&quot;;</span>
<span class="pc bpc" id="L2114" title="1 of 2 branches missed.">        else if (clsName.equals(&quot;int&quot;)) res = &quot;return 0;&quot;;</span>
<span class="pc bpc" id="L2115" title="1 of 2 branches missed.">        else if (clsName.equals(&quot;bool&quot;)) res = &quot;return false;&quot;;</span>
<span class="pc bpc" id="L2116" title="1 of 2 branches missed.">        else if (clsName.equals(&quot;byte&quot;)) res = &quot;return 0;&quot;;</span>
<span class="pc bpc" id="L2117" title="1 of 2 branches missed.">        else if (clsName.equals(&quot;long&quot;)) res = &quot;return 0;&quot;;</span>
<span class="pc bpc" id="L2118" title="1 of 2 branches missed.">        else if (clsName.equals(&quot;float&quot;)) res = &quot;return 0.0;&quot;;</span>
<span class="pc bpc" id="L2119" title="1 of 2 branches missed.">        else if (clsName.equals(&quot;double&quot;)) res = &quot;return 0.0;&quot;;</span>

<span class="fc bfc" id="L2121" title="All 2 branches covered.">        if (res == null) {</span>
<span class="fc" id="L2122">            return &quot;&quot;; // in doubt, let the choice to the user</span>
        }
<span class="fc" id="L2124">        return indent + res + LINE_SEPARATOR;</span>
    }

    private String generateTaggedValues(Object e, int tagSelection) {
<span class="fc" id="L2128">        Iterator iter = getFacade().getTaggedValues(e);</span>
<span class="fc bfc" id="L2129" title="All 2 branches covered.">        if (!iter.hasNext()) {</span>
<span class="fc" id="L2130">            return &quot;&quot;;</span>
        }
<span class="fc" id="L2132">        StringBuffer buf = new StringBuffer();</span>
<span class="fc" id="L2133">        boolean first = true;</span>

<span class="fc" id="L2135">        String s = null;</span>
<span class="fc bfc" id="L2136" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L2137">            s = generateTaggedValue(iter.next(), tagSelection);</span>
<span class="pc bpc" id="L2138" title="1 of 4 branches missed.">            if (s != null &amp;&amp; s.length() &gt; 0) {</span>
<span class="pc bpc" id="L2139" title="1 of 2 branches missed.">                if (first) {</span>
<span class="pc bpc" id="L2140" title="1 of 2 branches missed.">                    if (tagSelection == DOC_COMMENT_TAGS) {</span>
                        // insert main documentation for DocComment at first
                        String doc =
<span class="nc bnc" id="L2143" title="All 2 branches missed.">                            (DocumentationManager.hasDocs(e))</span>
<span class="nc" id="L2144">                            ? DocumentationManager.getDocs(e, indent)</span>
<span class="nc" id="L2145">                            : null;</span>
<span class="nc bnc" id="L2146" title="All 4 branches missed.">                        if (doc != null &amp;&amp; doc.trim().length() &gt; 0) {</span>
<span class="nc" id="L2147">                            buf.append(doc.substring(0, doc.indexOf(&quot;*/&quot;) + 1));</span>
<span class="nc" id="L2148">                            buf.append(&quot;  &quot;);</span>
                        }
                        else {
<span class="nc" id="L2151">                            buf.append(&quot;/** &quot;);</span>
                        }
<span class="nc" id="L2153">                    }</span>
                    else {
<span class="fc" id="L2155">                        buf.append(&quot;/* {&quot;);</span>
                    }
<span class="fc" id="L2157">                    first = false;</span>
                } // end first
                else {
<span class="nc bnc" id="L2160" title="All 2 branches missed.">                    if (tagSelection == DOC_COMMENT_TAGS) {</span>
<span class="nc" id="L2161">                        buf.append(LINE_SEPARATOR)</span>
<span class="nc" id="L2162">                            .append(indent).append(&quot; *  &quot;);</span>
                    }
                    else {
<span class="nc" id="L2165">                        buf.append(&quot;, &quot;);</span>
                    }
                } // end not first tag
<span class="fc" id="L2168">                buf.append(s);</span>
            } // end tag not empty
        } // end while

<span class="fc bfc" id="L2172" title="All 2 branches covered.">        if (!first) {</span>
<span class="pc bpc" id="L2173" title="1 of 2 branches missed.">            if (tagSelection == DOC_COMMENT_TAGS) {</span>
<span class="nc" id="L2174">                buf.append(LINE_SEPARATOR).append(indent).append(&quot; */&quot;)</span>
<span class="nc" id="L2175">                    .append(LINE_SEPARATOR);</span>
            } else {
<span class="fc" id="L2177">                buf.append (&quot;}*/&quot;).append(LINE_SEPARATOR);</span>
            }
        }
<span class="fc bfc" id="L2180" title="All 2 branches covered.">        else if (tagSelection == DOC_COMMENT_TAGS) {</span>
            // create at least main documentation field, if no other tag found
<span class="pc bpc" id="L2182" title="1 of 2 branches missed.">            String doc = (DocumentationManager.hasDocs(e))</span>
<span class="nc" id="L2183">                ? DocumentationManager.getDocs(e, indent)</span>
<span class="fc" id="L2184">                : null;</span>
<span class="pc bpc" id="L2185" title="3 of 4 branches missed.">            if (doc != null &amp;&amp; doc.trim().length() &gt; 0) {</span>
<span class="nc" id="L2186">                buf.append(doc).append(LINE_SEPARATOR);</span>
            }
        }

<span class="fc" id="L2190">        return buf.toString();</span>
    }

    private String generateTaggedValue(Object tv, int tagSelection) {
<span class="pc bpc" id="L2194" title="1 of 2 branches missed.">        if (tv == null) return &quot;&quot;;</span>
<span class="fc" id="L2195">        String s = generateUninterpreted(getFacade().getValueOfTag(tv));</span>

<span class="fc" id="L2197">        String tagName = getFacade().getTagOfTag(tv);</span>
<span class="pc bpc" id="L2198" title="3 of 8 branches missed.">        if (s == null || s.length() == 0 || s.equals(&quot;/** */&quot;)</span>
            || tagName == null 
<span class="pc bpc" id="L2200" title="1 of 2 branches missed.">            || (tagName.indexOf(&quot;include&quot;) != -1)</span>
<span class="pc bpc" id="L2201" title="1 of 2 branches missed.">            || (tagName.indexOf(&quot;_incl&quot;) != -1)) {</span>
<span class="fc" id="L2202">            return &quot;&quot;;</span>
        }
<span class="fc bfc" id="L2204" title="All 2 branches covered.">        if ((tagSelection == DOC_COMMENT_TAGS)</span>
<span class="pc bpc" id="L2205" title="1 of 2 branches missed.">                &amp;&amp; (isDocCommentTag(tagName))) {</span>
<span class="nc" id="L2206">            return generateDocComment4Tag(tagName) + s;</span>
<span class="fc bfc" id="L2207" title="All 2 branches covered.">        } else if (((tagSelection == ALL_BUT_DOC_TAGS)</span>
<span class="pc bpc" id="L2208" title="1 of 2 branches missed.">                     &amp;&amp; (!isDocCommentTag(tagName))</span>
<span class="pc bpc" id="L2209" title="1 of 2 branches missed.">                     &amp;&amp; (!tagName.equals(&quot;documentation&quot;))</span>
<span class="pc bpc" id="L2210" title="2 of 4 branches missed.">                     &amp;&amp; (!tagName.equals(&quot;javadocs&quot;))</span>
                    )
                   || (tagSelection == ALL_TAGS)) {
<span class="fc" id="L2213">            return tagName + &quot;=&quot; + s;</span>
        } else {
<span class="fc" id="L2215">            return &quot;&quot;;</span>
        }
    }

    private Collection findTagValues(Object item, String searchedName) {
<span class="fc" id="L2220">        Collection result = new Vector();</span>

<span class="fc" id="L2222">        Iterator iter = getFacade().getTaggedValues(item);</span>
<span class="fc" id="L2223">        String s = null;</span>
<span class="fc bfc" id="L2224" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L2225">            Object tag = iter.next();</span>
<span class="fc" id="L2226">            String tagOfTag = getFacade().getTagOfTag(tag);</span>
<span class="pc bpc" id="L2227" title="3 of 4 branches missed.">            if (tagOfTag != null &amp;&amp; tagOfTag.equals(searchedName)) {</span>
<span class="nc" id="L2228">                s = getFacade().getValueOfTag(tag);</span>
<span class="nc bnc" id="L2229" title="All 4 branches missed.">                if (s != null &amp;&amp; s.length() != 0) result.add(s);</span>
            }
<span class="fc" id="L2231">        }</span>
<span class="fc" id="L2232">        return result;</span>
    }

    private boolean isDocCommentTag(String tagName) {
<span class="fc" id="L2236">        boolean result = false;</span>
<span class="pc bpc" id="L2237" title="1 of 2 branches missed.">        if (tagName.equals (&quot;inv&quot;)) {</span>
<span class="nc" id="L2238">            result = true;</span>
        }
<span class="pc bpc" id="L2240" title="1 of 2 branches missed.">        else if (tagName.equals (&quot;post&quot;)) {</span>
<span class="nc" id="L2241">            result = true;</span>
        }
<span class="pc bpc" id="L2243" title="1 of 2 branches missed.">        else if (tagName.equals (&quot;pre&quot;)) {</span>
<span class="nc" id="L2244">            result = true;</span>
        }
<span class="pc bpc" id="L2246" title="1 of 2 branches missed.">        else if (tagName.equals (&quot;author&quot;)) {</span>
<span class="nc" id="L2247">            result = true;</span>
        }
<span class="pc bpc" id="L2249" title="1 of 2 branches missed.">        else if (tagName.equals (&quot;version&quot;)) {</span>
<span class="nc" id="L2250">            result = true;</span>
        }
<span class="pc bpc" id="L2252" title="1 of 2 branches missed.">        else if (tagName.equals (&quot;see&quot;)) {</span>
<span class="nc" id="L2253">            result = true;</span>
        }
<span class="pc bpc" id="L2255" title="1 of 2 branches missed.">        else if (tagName.equals (&quot;param&quot;)) {</span>
<span class="nc" id="L2256">            result = true;</span>
        }
<span class="fc" id="L2258">        return result;</span>
    }

    private String generateDocComment4Tag(String tagName) {
<span class="nc bnc" id="L2262" title="All 2 branches missed.">        if (tagName.equals (&quot;inv&quot;)) {</span>
<span class="nc" id="L2263">            return &quot;@invariant &quot;;</span>
        }
<span class="nc bnc" id="L2265" title="All 2 branches missed.">        else if (tagName.equals (&quot;post&quot;)) {</span>
<span class="nc" id="L2266">            return &quot;@postcondition &quot;;</span>
        }
<span class="nc bnc" id="L2268" title="All 2 branches missed.">        else if (tagName.equals (&quot;pre&quot;)) {</span>
<span class="nc" id="L2269">            return &quot;@precondition &quot;;</span>
        }
<span class="nc bnc" id="L2271" title="All 2 branches missed.">        else if (tagName.equals (&quot;author&quot;)) {</span>
<span class="nc" id="L2272">            return &quot;@author &quot;;</span>
        }
<span class="nc bnc" id="L2274" title="All 2 branches missed.">        else if (tagName.equals (&quot;version&quot;)) {</span>
<span class="nc" id="L2275">            return &quot;@version &quot;;</span>
        }
<span class="nc bnc" id="L2277" title="All 2 branches missed.">        else if (tagName.equals (&quot;see&quot;)) {</span>
<span class="nc" id="L2278">            return &quot;@see &quot;;</span>
        }
<span class="nc bnc" id="L2280" title="All 2 branches missed.">        else if (tagName.equals (&quot;param&quot;)) {</span>
<span class="nc" id="L2281">            return &quot;@param &quot;;</span>
        }
<span class="nc" id="L2283">        else return &quot;&quot;;</span>
    }

    /**
     * Enhance/Create the doccomment for the given model element,
     * including tags for any OCL constraints connected to the model
     * element. The tags generated are suitable for use with the ocl
     * injector which is part of the Dresden OCL Toolkit and are in
     * detail:
     *
     * &amp;nbsp;@invariant for each invariant specified
     * &amp;nbsp;@precondition for each precondition specified
     * &amp;nbsp;@postcondition for each postcondition specified
     * &amp;nbsp;@key-type specifying the class of the keys of a mapped association
     * &amp;nbsp; Currently mapped associations are not supported yet...
     * &amp;nbsp;@element-type specifying the class referenced in an association
     *
     * @since 2001-09-26 ArgoUML 0.9.3
     * @author Steffen Zschaler
     *
     * @param me the model element for which the documentation comment is needed
     * @param ae the association end which is represented by the model element
     * @return the documentation comment for the specified model element, either
     * enhanced or completely generated
     */
    private String generateConstraintEnrichedDocComment(Object me, Object ae) {
        // list tagged values for documentation
<span class="fc" id="L2310">        String s = generateTaggedValues (me, DOC_COMMENT_TAGS);</span>

<span class="pc bpc" id="L2312" title="1 of 2 branches missed.">        if (getFacade().getUpper(ae) != 1) {</span>
            // Multiplicity greater 1, that means we will generate some sort of
            // collection, so we need to specify the element type tag
<span class="fc" id="L2315">            StringBuffer sDocComment = new StringBuffer(80);</span>

            // Prepare doccomment
<span class="pc bpc" id="L2318" title="2 of 4 branches missed.">            if (!(s == null || &quot;&quot;.equals(s))) {</span>
                // Just remove closing &quot;*/&quot;
<span class="nc" id="L2320">                sDocComment.append(indent)</span>
<span class="nc" id="L2321">                    .append(s.substring(0, s.indexOf(&quot;*/&quot;) + 1));</span>
            }
            else {
<span class="fc" id="L2324">                sDocComment.append(indent).append(&quot;/**&quot;).append(LINE_SEPARATOR);</span>
<span class="fc" id="L2325">                sDocComment.append(indent).append(&quot; *&quot;);</span>
            }

            // Build doccomment
<span class="fc" id="L2329">            Object type = getFacade().getType(ae);</span>
<span class="pc bpc" id="L2330" title="1 of 2 branches missed.">            if (type != null) {</span>
<span class="fc" id="L2331">                sDocComment.append(&quot; @element-type &quot;);</span>
<span class="fc" id="L2332">                sDocComment.append(getFacade().getName(type));</span>
            }
<span class="fc" id="L2334">            sDocComment.append(LINE_SEPARATOR).append(indent)</span>
<span class="fc" id="L2335">                .append(&quot; */&quot;).append(LINE_SEPARATOR);</span>
<span class="fc" id="L2336">            return sDocComment.toString();</span>
        }
<span class="nc bnc" id="L2338" title="All 2 branches missed.">        return (s != null) ? s : &quot;&quot;;</span>
    }

    /**
     * 
     * @param a association object
     * @param ae association end attached to the classifier
     *        for which the code is to be generated
     * @param parts the buffers associated with the public, protected
     *        and private parts, where the code is to be written.
     */
    private void generateAssociationFrom(Object a, Object ae,
            StringBuffer[] parts) {
        // TODO: does not handle n-ary associations

<span class="fc" id="L2353">        Collection connections = getFacade().getConnections(a);</span>
<span class="fc" id="L2354">        Iterator connEnum = connections.iterator();</span>
<span class="fc bfc" id="L2355" title="All 2 branches covered.">        while (connEnum.hasNext()) {</span>
<span class="fc" id="L2356">            Object ae2 = connEnum.next();</span>
<span class="fc bfc" id="L2357" title="All 2 branches covered.">            if (ae2 != ae) {</span>
<span class="fc" id="L2358">                int p = getVisibilityPart(ae2);</span>
<span class="pc bpc" id="L2359" title="1 of 2 branches missed.">                if (p &gt;= 0) {</span>
<span class="fc" id="L2360">                    StringBuffer sb = parts[p];</span>
<span class="fc" id="L2361">                    sb.append(LINE_SEPARATOR);</span>
<span class="fc" id="L2362">                    String assend = generateAssociationEnd(ae2);</span>
<span class="pc bpc" id="L2363" title="1 of 2 branches missed.">                    if (assend.length() &gt; 0) {</span>
<span class="fc" id="L2364">                        String comment =</span>
<span class="fc" id="L2365">                            generateConstraintEnrichedDocComment(a, ae2);</span>
<span class="pc bpc" id="L2366" title="1 of 2 branches missed.">                        if (comment.length() &gt; 0)</span>
<span class="fc" id="L2367">                            sb.append(comment);</span>
                        // both comment and assend ends with simple newline
<span class="fc" id="L2369">                        sb.append(indent).append(assend);</span>
                    }

<span class="fc" id="L2372">                    String tv = generateTaggedValues(a, ALL_BUT_DOC_TAGS);</span>
<span class="pc bpc" id="L2373" title="2 of 4 branches missed.">                    if (tv != null &amp;&amp; tv.length() &gt; 0) {</span>
<span class="nc" id="L2374">                        sb.append(indent).append(tv);</span>
                    }
                }
            }
<span class="fc" id="L2378">        }</span>
<span class="fc" id="L2379">    }</span>

    private String generateAssociationEnd(Object ae) {
<span class="pc bpc" id="L2382" title="1 of 2 branches missed.">        if (!getFacade().isNavigable(ae)) {</span>
<span class="nc" id="L2383">            return &quot;&quot;;</span>
        }
<span class="pc bpc" id="L2385" title="1 of 2 branches missed.">        if (getFacade().isAbstract(</span>
<span class="fc" id="L2386">                getFacade().getAssociation(ae))) {</span>
<span class="nc" id="L2387">            return &quot;&quot;;</span>
        }
<span class="fc" id="L2389">        StringBuffer sb = new StringBuffer(80);</span>

<span class="pc bpc" id="L2391" title="1 of 2 branches missed.">        if (getFacade().isStatic(ae)) {</span>
<span class="nc" id="L2392">            sb.append(&quot;static &quot;);</span>
        }

<span class="fc" id="L2395">        String n = getFacade().getName(ae);</span>
<span class="fc" id="L2396">        Object asc = getFacade().getAssociation(ae);</span>
<span class="fc" id="L2397">        String ascName = getFacade().getName(asc);</span>
<span class="fc" id="L2398">        String name = null;</span>

<span class="pc bpc" id="L2400" title="3 of 4 branches missed.">        if (n != null &amp;&amp; n.length() &gt; 0) {</span>
<span class="nc" id="L2401">            name = n;</span>
<span class="pc bpc" id="L2402" title="2 of 4 branches missed.">        } else if (ascName != null &amp;&amp; ascName.length() &gt; 0) {</span>
<span class="fc" id="L2403">            name = ascName;</span>
        } else {
<span class="nc" id="L2405">            name = &quot;my&quot; + generateClassifierRef(getFacade().getType(ae));</span>
        }

        String modifier;
<span class="pc bpc" id="L2409" title="1 of 2 branches missed.">        if (getFacade().isAAssociationClass(asc)) {</span>
            // With an association class, we actually make an association
            // between us and the association class itself.
            // Usually, this is a pointer or a reference, so default
            // to a pointer.
<span class="nc" id="L2414">            modifier = generateAttributeParameterModifier(asc, &quot;*&quot;);</span>
            // add the association class in the dependency list
<span class="nc bnc" id="L2416" title="All 2 branches missed.">            addDependency(asc, !checkIncludeNeeded4Element(ae)); </span>
        } else {
<span class="fc" id="L2418">            modifier = generateAttributeParameterModifier(ae);</span>
            // add the type of the association end in the dependency list
<span class="fc bfc" id="L2420" title="All 2 branches covered.">            boolean predecl = !checkIncludeNeeded4Element(ae);</span>
<span class="fc" id="L2421">            addDependency(getFacade().getType(ae), predecl);</span>
        }
        
<span class="fc" id="L2424">        sb.append(generateMultiplicity(ae, name,</span>
<span class="fc" id="L2425">                             getFacade().getMultiplicity(ae),</span>
                             modifier));

<span class="fc" id="L2428">        return (sb.append(&quot;;&quot;).append(LINE_SEPARATOR)).toString();</span>
    }


    private String generateGeneralization(Collection generalizations) {
<span class="pc bpc" id="L2433" title="1 of 2 branches missed.">        if (generalizations == null) {</span>
<span class="nc" id="L2434">            return &quot;&quot;;</span>
        }
<span class="fc" id="L2436">        StringBuffer sb = new StringBuffer(80);</span>
<span class="fc" id="L2437">        Iterator genEnum = generalizations.iterator();</span>
<span class="fc bfc" id="L2438" title="All 2 branches covered.">        while (genEnum.hasNext()) {</span>
<span class="fc" id="L2439">            Object generalization = genEnum.next();</span>
<span class="fc" id="L2440">            Object ge = getFacade().getGeneral(generalization);</span>
<span class="pc bpc" id="L2441" title="1 of 2 branches missed.">            if (ge != null) {</span>
<span class="pc bpc" id="L2442" title="1 of 2 branches missed.">                if (sb.length() &gt; 0) sb.append(&quot;, &quot;);</span>
                String visTag =
<span class="fc" id="L2444">                    getFacade().getTaggedValueValue(generalization,</span>
<span class="fc" id="L2445">                            TV_NAME_INHERITANCE_VISIBILITY).trim();</span>
<span class="pc bpc" id="L2446" title="1 of 4 branches missed.">                if (visTag != null &amp;&amp; !visTag.equals(&quot;&quot;)) {</span>
<span class="fc" id="L2447">                    sb.append(visTag).append(&quot; &quot;);</span>
                } else {
<span class="pc bpc" id="L2449" title="1 of 2 branches missed.">                    if (getFacade().isAInterface(ge)) {</span>
<span class="nc" id="L2450">                        sb.append(&quot;virtual public &quot;);</span>
                    } else {
<span class="fc" id="L2452">                        sb.append(&quot;public &quot;);</span>
                    }
                }
<span class="fc" id="L2455">                sb.append(generateNameWithPkgSelection(ge));</span>
                // add the type of the base class in the dependency list
<span class="fc" id="L2457">                addDependency(ge, false);</span>
            }
<span class="fc" id="L2459">        }</span>
<span class="fc" id="L2460">        return sb.toString();</span>
    }

    private String generateSpecification(Object cls) {
<span class="fc" id="L2464">        Collection deps = getFacade().getClientDependencies(cls);</span>
<span class="fc" id="L2465">        Iterator depIterator = deps.iterator();</span>
<span class="fc" id="L2466">        StringBuffer sb = new StringBuffer(80);</span>

<span class="fc bfc" id="L2468" title="All 2 branches covered.">        while (depIterator.hasNext()) {</span>
<span class="fc" id="L2469">            Object dependency = depIterator.next();</span>
<span class="pc bpc" id="L2470" title="1 of 2 branches missed.">            if (getFacade().isAAbstraction(dependency)</span>
<span class="pc bpc" id="L2471" title="1 of 2 branches missed.">                    &amp;&amp; getFacade().isRealize(dependency)) {</span>
<span class="pc bpc" id="L2472" title="1 of 2 branches missed.">                if (sb.length() &gt; 0) sb.append(&quot;, &quot;);</span>
<span class="fc" id="L2473">                Object iFace = getFacade().getSuppliers(dependency)</span>
<span class="fc" id="L2474">                    .iterator().next();</span>
                String visTag =
<span class="fc" id="L2476">                    getFacade().getTaggedValueValue(dependency,</span>
<span class="fc" id="L2477">                            TV_NAME_INHERITANCE_VISIBILITY).trim();</span>
<span class="pc bpc" id="L2478" title="1 of 4 branches missed.">                if (visTag != null &amp;&amp; !visTag.equals(&quot;&quot;)) {</span>
<span class="fc" id="L2479">                    sb.append(visTag).append(&quot; &quot;);</span>
                } else {
<span class="fc" id="L2481">                    sb.append(&quot;virtual public &quot;);</span>
                }
<span class="fc" id="L2483">                sb.append(generateNameWithPkgSelection(iFace));</span>
                // add the type of the interface in the dependency list
<span class="fc" id="L2485">                addDependency(iFace, false);</span>
            }
<span class="fc" id="L2487">        }</span>
<span class="fc" id="L2488">        return sb.toString();</span>
    }

    private String generateVisibility(Object o) {
<span class="pc bpc" id="L2492" title="1 of 2 branches missed.">        if (getFacade().isAAttribute(o)) {</span>
<span class="fc" id="L2493">            return &quot;&quot;;</span>
        }
        // cut'n'pasted from GeneratorJava.java
<span class="nc bnc" id="L2496" title="All 2 branches missed.">        if (getFacade().isAFeature(o)) {</span>
            // TODO: The src_visibility tag doesn't appear to be created
            // anywhere by ArgoUML currently
<span class="nc" id="L2499">            Object tv = getFacade().getTaggedValue(o, &quot;src_visibility&quot;);</span>
<span class="nc bnc" id="L2500" title="All 2 branches missed.">            if (tv != null) {</span>
<span class="nc" id="L2501">                String tagged = (String) getFacade().getValue(tv);</span>
<span class="nc bnc" id="L2502" title="All 2 branches missed.">                if (tagged != null) {</span>
<span class="nc bnc" id="L2503" title="All 2 branches missed.">                    if (tagged.trim().equals(&quot;&quot;)</span>
<span class="nc bnc" id="L2504" title="All 2 branches missed.">                            || tagged.trim().toLowerCase().equals(&quot;default&quot;)</span>
                            // We should never get &quot;package&quot;, but just in case
<span class="nc bnc" id="L2506" title="All 2 branches missed.">                            || tagged.trim().toLowerCase().equals(&quot;package&quot;)) {</span>
<span class="nc" id="L2507">                        return &quot;&quot;;</span>
                    } 
<span class="nc" id="L2509">                    return tagged + &quot;: &quot;;</span>
                }
            }
        }
<span class="nc bnc" id="L2513" title="All 2 branches missed.">        if (getFacade().isAModelElement(o)) {</span>
<span class="nc bnc" id="L2514" title="All 2 branches missed.">            if (getFacade().isPublic(o))</span>
<span class="nc" id="L2515">                return &quot;public: &quot;;</span>
<span class="nc bnc" id="L2516" title="All 2 branches missed.">            if (getFacade().isPrivate(o))</span>
<span class="nc" id="L2517">                return &quot;private: &quot;;</span>
<span class="nc bnc" id="L2518" title="All 2 branches missed.">            if (getFacade().isProtected(o))</span>
<span class="nc" id="L2519">                return &quot;protected: &quot;;</span>
<span class="nc bnc" id="L2520" title="All 2 branches missed.">            if (getFacade().isPackage(o))</span>
                // TODO: is default visibility the right thing here?
<span class="nc" id="L2522">                return &quot;&quot;;</span>
        }
<span class="nc bnc" id="L2524" title="All 2 branches missed.">        if (getFacade().isAVisibilityKind(o)) {</span>
<span class="nc bnc" id="L2525" title="All 2 branches missed.">            if (getVisibilityKind().getPublic().equals(o))</span>
<span class="nc" id="L2526">                return &quot;public: &quot;;</span>
<span class="nc bnc" id="L2527" title="All 2 branches missed.">            if (getVisibilityKind().getPrivate().equals(o))</span>
<span class="nc" id="L2528">                return &quot;private: &quot;;</span>
<span class="nc bnc" id="L2529" title="All 2 branches missed.">            if (getVisibilityKind().getProtected().equals(o))</span>
<span class="nc" id="L2530">                return &quot;protected: &quot;;</span>
<span class="nc bnc" id="L2531" title="All 2 branches missed.">            if (getVisibilityKind().getPackage().equals(o))</span>
                // TODO: is default visibility the right thing here?
<span class="nc" id="L2533">                return &quot;&quot;;</span>
        }
<span class="nc" id="L2535">        return &quot;&quot;;</span>
    }

    /**
     * @param me The model element to generate scope for.
     * @return The generated text representing the scope.
     */
    private String generateScope(Object me) {
<span class="pc bpc" id="L2543" title="1 of 2 branches missed.">        if (getFacade().isStatic(me)) {</span>
<span class="nc" id="L2544">            return &quot;static &quot;;</span>
        }
<span class="fc" id="L2546">        return &quot;&quot;;</span>
    }


    /**
     * Generate &quot;abstract&quot; keyword for an abstract operation.
     * In C++, since it does not have an explicit &quot;interface&quot; keyword, we must
     * check against this and set the operation to abstract if so.
     */
    private String generateAbstractness(Object op) {
        // use Model subsystem Facade to check if the operation is 
        // owned by an interface
<span class="fc" id="L2558">        Object opOwner = getFacade().getOwner(op);</span>
<span class="pc bpc" id="L2559" title="2 of 4 branches missed.">        if (getFacade().isAbstract(op) || getFacade().isAInterface(opOwner)) {</span>
<span class="nc" id="L2560">            return &quot; = 0&quot;;</span>
        }
<span class="fc" id="L2562">        return &quot;&quot;;</span>
    }

    /**
     * Generate &quot;const&quot; keyword for query operations.
     */
    private String generateOperationChangeability(Object op) {
<span class="pc bpc" id="L2569" title="1 of 2 branches missed.">        if (getFacade().isQuery(op)) {</span>
<span class="nc" id="L2570">            return &quot;const &quot;;</span>
        }
<span class="fc" id="L2572">        return &quot;&quot;;</span>
    }

    /**
     * Generate &quot;const&quot; keyword for const pointer/reference parameters.
     */
    private String generateParameterChangeability(Object par) {
<span class="fc" id="L2579">        int parType = getAttributeModifierType(par);</span>
<span class="pc bpc" id="L2580" title="3 of 4 branches missed.">        if (parType != -1 &amp;&amp; parType != NORMAL_MOD </span>
<span class="nc bnc" id="L2581" title="All 2 branches missed.">                &amp;&amp; getFacade().getKind(par) != null </span>
<span class="nc bnc" id="L2582" title="All 2 branches missed.">                &amp;&amp; (getFacade().getKind(par)).equals(</span>
<span class="nc" id="L2583">                        getDirectionKind().getInParameter())) {</span>
<span class="nc" id="L2584">            return &quot;const &quot;;</span>
        }
<span class="fc" id="L2586">        return &quot;&quot;;</span>
    }

    private String generateStructuralFeatureChangeability(Object sf) {
<span class="pc bpc" id="L2590" title="1 of 2 branches missed.">        if (getFacade().isReadOnly(sf)) {</span>
<span class="nc" id="L2591">            return &quot;const &quot;;</span>
        }
<span class="fc" id="L2593">        return &quot;&quot;;</span>
    }

    private String generateMultiplicity(Object item, String name,
            Object m, String modifier) {
<span class="fc" id="L2598">        String type = null;</span>
<span class="fc" id="L2599">        String containerType = null;</span>
<span class="fc" id="L2600">        Object typeCls = null;</span>
<span class="fc bfc" id="L2601" title="All 2 branches covered.">        if (getFacade().isAAssociationEnd(item)) {</span>
            // take into account association classes
<span class="fc" id="L2603">            Object assoc = getFacade().getAssociation(item);</span>
<span class="pc bpc" id="L2604" title="1 of 2 branches missed.">            if (getFacade().isAAssociationClass(assoc)) {</span>
<span class="nc" id="L2605">                typeCls = assoc;</span>
<span class="nc" id="L2606">                name += &quot;Assoc&quot;;</span>
            }
<span class="fc" id="L2608">            else typeCls = getFacade().getType(item);</span>
<span class="pc bpc" id="L2609" title="1 of 2 branches missed.">        } else if (getFacade().isAAttribute(item)) {</span>
<span class="fc" id="L2610">            typeCls = getFacade().getType(item);</span>
<span class="nc bnc" id="L2611" title="All 2 branches missed.">        } else if (getFacade().isAClassifier(item)) {</span>
<span class="nc" id="L2612">            typeCls = item;</span>
        } else {
<span class="nc" id="L2614">            type = &quot;&quot;;</span>
        }
<span class="pc bpc" id="L2616" title="1 of 2 branches missed.">        if (typeCls != null) {</span>
<span class="fc" id="L2617">            type = generateNameWithPkgSelection(typeCls);</span>
        }
<span class="fc bfc" id="L2619" title="All 2 branches covered.">        if (m == null) {</span>
<span class="fc" id="L2620">            return (type + &quot; &quot; + modifier + name);</span>
        }
<span class="fc" id="L2622">        StringBuffer sb = new StringBuffer(80);</span>
<span class="fc" id="L2623">        int countUpper = getFacade().getUpper(m);</span>
<span class="fc" id="L2624">        int countLower = getFacade().getLower(m);</span>

<span class="fc bfc" id="L2626" title="All 4 branches covered.">        if (countUpper == 1 &amp;&amp; countLower == 1) {</span>
            // simple generate identifier for default 1:1 multiplicity
<span class="fc" id="L2628">            sb.append(type).append(' ').append(modifier).append(name);</span>
<span class="pc bpc" id="L2629" title="1 of 4 branches missed.">        } else if (countUpper == 1 &amp;&amp; countLower == 0) {</span>
            // use a simple pointer for 0:1 multiplicity
            // TODO: use an auto_ptr in case of attributes or compositions
<span class="fc" id="L2632">            sb.append(type).append(' ').append(modifier)</span>
<span class="fc" id="L2633">                .append(&quot;* &quot;).append(name);</span>
<span class="pc bpc" id="L2634" title="1 of 2 branches missed.">        } else if (countUpper == countLower) {</span>
            // fixed array -&gt; &lt;type&gt; &lt;name&gt;[&lt;count&gt;];
<span class="nc" id="L2636">            sb.append(type).append(' ').append(modifier).append(name)</span>
<span class="nc" id="L2637">                .append(&quot;[ &quot; + countUpper + &quot;]&quot;);</span>
        } else {
            // variable association -&gt; if no tag found use vector
            // else search for tag:
            // &lt;MultipliciyType&gt; : vector|list|slist|map|stack|stringmap
            String multType =
<span class="fc" id="L2643">                getFacade().getTaggedValueValue(item, </span>
                        TV_NAME_MULTIPLICITY_TYPE);
<span class="pc bpc" id="L2645" title="1 of 4 branches missed.">            if (multType != null &amp;&amp; multType.length() &gt; 0) {</span>
<span class="pc bpc" id="L2646" title="1 of 2 branches missed.">                if (multType.equals(&quot;vector&quot;)) {</span>
<span class="nc" id="L2647">                    containerType = &quot;vector&quot;;</span>
<span class="fc bfc" id="L2648" title="All 2 branches covered.">                } else if (multType.equals(&quot;list&quot;)) {</span>
<span class="fc" id="L2649">                    containerType = &quot;list&quot;;</span>
<span class="pc bpc" id="L2650" title="1 of 2 branches missed.">                } else if (multType.equals(&quot;slist&quot;)) {</span>
<span class="nc" id="L2651">                    containerType = &quot;slist&quot;;</span>
<span class="pc bpc" id="L2652" title="1 of 2 branches missed.">                } else if (multType.equals(&quot;map&quot;)) {</span>
                    // FIXME: map does not work this way, needs a index type
<span class="nc" id="L2654">                    containerType = &quot;map&quot;;</span>
<span class="pc bpc" id="L2655" title="1 of 2 branches missed.">                } else if (multType.equals(&quot;stack&quot;)) {</span>
<span class="nc" id="L2656">                    containerType = &quot;stack&quot;;</span>
<span class="pc bpc" id="L2657" title="1 of 2 branches missed.">                } else if (multType.equals(&quot;stringmap&quot;)) {</span>
<span class="fc" id="L2658">                    systemInc.add(&quot;string&quot;);</span>
<span class="fc" id="L2659">                    systemInc.add(&quot;map&quot;);</span>
<span class="fc" id="L2660">                    sb.append(stdPrefix + &quot;map&lt;&quot; + stdPrefix + &quot;string, &quot;);</span>
<span class="pc bpc" id="L2661" title="1 of 2 branches missed.">                    if (modifier.indexOf('&amp;') != -1) {</span>
<span class="nc" id="L2662">                        LOG.warning(&quot;cannot generate STL container &quot;</span>
                                    + &quot;with references, using pointers&quot;);
<span class="nc" id="L2664">                        modifier = &quot;*&quot;;</span>
                    }
<span class="fc" id="L2666">                    sb.append(type).append(modifier);</span>
<span class="fc" id="L2667">                    sb.append(&quot; &gt; &quot;).append(name);</span>
                } else {
<span class="nc" id="L2669">                    LOG.warning(&quot;unknown &quot; + TV_NAME_MULTIPLICITY_TYPE + &quot; \&quot;&quot; </span>
                                + multType + &quot;\&quot;, using default&quot;);
<span class="nc" id="L2671">                    containerType = &quot;vector&quot;;</span>
                }
            } else {
<span class="fc" id="L2674">                containerType = &quot;vector&quot;;</span>
            }

<span class="fc bfc" id="L2677" title="All 2 branches covered.">            if (containerType != null) {</span>
                // these container are declared the same except the name
<span class="fc" id="L2679">                systemInc.add(containerType);</span>
<span class="fc" id="L2680">                sb.append(stdPrefix).append(containerType).append(&quot;&lt; &quot;);</span>
<span class="pc bpc" id="L2681" title="1 of 2 branches missed.">                if (modifier.indexOf('&amp;') != -1) {</span>
<span class="nc" id="L2682">                    LOG.warning(&quot;cannot generate STL container &quot;</span>
                                + &quot;with references, using pointers&quot;);
<span class="nc" id="L2684">                    modifier = &quot;*&quot;;</span>
                }
<span class="fc" id="L2686">                sb.append(type).append(modifier);</span>
<span class="fc" id="L2687">                sb.append(&quot; &gt; &quot;).append(name);</span>
            }
        }
<span class="fc" id="L2690">        return sb.toString();</span>
    }
    
    /** 
     * Load configurable parameters.
     * TODO: Why is this public? - tfm
     */
    public void loadConfig() {
<span class="fc" id="L2698">        int indWidth = Configuration.getInteger(KEY_CPP_INDENT, 4);</span>
<span class="fc" id="L2699">        char[] ind = new char[indWidth];</span>
<span class="fc bfc" id="L2700" title="All 2 branches covered.">        for (int i = 0; i &lt; indWidth; i++)</span>
<span class="fc" id="L2701">            ind[i] = ' ';</span>
<span class="fc" id="L2702">        this.indent = new String(ind);</span>
<span class="fc" id="L2703">        lfBeforeCurly =</span>
<span class="fc" id="L2704">            Configuration.getBoolean(KEY_CPP_LF_BEFORE_CURLY, false);</span>
<span class="fc" id="L2705">        verboseDocs = Configuration.getBoolean(KEY_CPP_VERBOSE_COMM, false);</span>
<span class="fc" id="L2706">        int useSect = Configuration.getInteger(KEY_CPP_SECT,</span>
                                               Section.SECT_NORMAL);
<span class="fc" id="L2708">        Section.setUseSect(useSect);</span>
<span class="fc" id="L2709">        hdrGuardUpperCase = Configuration.getBoolean(</span>
                KEY_CPP_HEADER_GUARD_UPPERCASE, false);
<span class="fc" id="L2711">        hdrGuardGUID = Configuration.getBoolean(</span>
                KEY_CPP_HEADER_GUARD_GUID, false);
        
<span class="fc" id="L2714">        int defaultInlineStyle = Configuration.getInteger(</span>
<span class="fc" id="L2715">                KEY_CPP_DEFAULT_INLINE, Inline.getDefaultDefaultStyle());</span>
<span class="fc" id="L2716">        Inline.setDefaultStyle(defaultInlineStyle);</span>
<span class="fc" id="L2717">    }</span>

    // Methods used by Settings dialog
    
    /**
     * @return true if the generator outputs a newline before the
     * curly brace starting a class declaration.
     */
    public boolean isLfBeforeCurly() {
<span class="nc" id="L2726">        return lfBeforeCurly;</span>
    }

    /**
     * Sets whether to output a newline character before the curly
     * brace starting a class declaration.
     * @param beforeCurly true to generate the '{' on a line on its own.
     */
    public void setLfBeforeCurly(boolean beforeCurly) {
<span class="nc" id="L2735">        this.lfBeforeCurly = beforeCurly;</span>
<span class="nc" id="L2736">        Configuration.setBoolean(KEY_CPP_LF_BEFORE_CURLY, beforeCurly);</span>
<span class="nc" id="L2737">    }</span>

    /**
     * @return If the generator generates verbose comments and docs or not.
     */
    public boolean isVerboseDocs() {
<span class="nc" id="L2743">        return verboseDocs;</span>
    }
    
    /**
     * Tells whether to generate verbose comments and docs or not.
     * @param verbose true to generate more verbose comments.
     */
    public void setVerboseDocs(boolean verbose) {
<span class="fc" id="L2751">        this.verboseDocs = verbose;</span>
<span class="fc" id="L2752">        Configuration.setBoolean(KEY_CPP_VERBOSE_COMM, verbose);</span>
<span class="fc" id="L2753">    }</span>

    /**
     * @return The current width of the indentation.
     */
    public int getIndent() {
<span class="nc" id="L2759">        return indent.length();</span>
    }

    /**
     * Sets the indentation width.
     * @param indWidth The number of spaces to use for indentation.
     */
    public void setIndent(int indWidth) {
<span class="nc" id="L2767">        char[] ind = new char[indWidth];</span>
<span class="nc bnc" id="L2768" title="All 2 branches missed.">        for (int i = 0; i &lt; indWidth; i++)</span>
<span class="nc" id="L2769">            ind[i] = ' ';</span>
<span class="nc" id="L2770">        this.indent = new String(ind);</span>
<span class="nc" id="L2771">        Configuration.setInteger(KEY_CPP_INDENT, indWidth);</span>
<span class="nc" id="L2772">    }</span>

    /**
     * @return Whether sections are generated and how.
     * @see #setUseSect(int)
     */
    public int getUseSect() {
<span class="nc" id="L2779">        return Section.getUseSect();</span>
    }

    /**
     * Tells the generator if and how to generate sections.
     * @param use Must be one of: 
     * &lt;ul&gt;
     *   &lt;li&gt;SECT_NONE: sections are not generated;&lt;/li&gt;
     *   &lt;li&gt;SECT_NORMAL: sections are generated;&lt;/li&gt;
     *   &lt;li&gt;SECT_BRIEF: sections are generated, but the &quot;do not delete...&quot;
     *       line is skipped.&lt;/li&gt;
     * &lt;/ul&gt;
     */
    public void setUseSect(int use) {
<span class="fc" id="L2793">        Section.setUseSect(use);</span>
<span class="fc" id="L2794">        Configuration.setInteger(KEY_CPP_SECT, use);</span>
<span class="fc" id="L2795">    }</span>

    /**
     * @return true if the generator outputs a header guard in upper case.
     */
    public boolean isHeaderGuardUpperCase() {
<span class="fc" id="L2801">        return hdrGuardUpperCase;</span>
    }

    /**
     * Sets how to output header guard.
     * @param upperCase true to generate upper case header guard.
     */
    public void setHeaderGuardUpperCase(boolean upperCase) {
<span class="nc" id="L2809">        this.hdrGuardUpperCase = upperCase;</span>
<span class="nc" id="L2810">        Configuration.setBoolean(KEY_CPP_HEADER_GUARD_UPPERCASE, upperCase);</span>
<span class="nc" id="L2811">    }</span>
    
    /**
     * @return true if the generator should add GUID to header guard.
     */
    public boolean isHeaderGuardGUID() {
<span class="nc" id="L2817">        return hdrGuardGUID;</span>
    }

    /**
     * Sets how to output header guard.
     * @param addGUID true to add GUID to header guard.
     */
    public void setHeaderGuardGUID(boolean addGUID) {
<span class="fc" id="L2825">        this.hdrGuardGUID = addGUID;</span>
<span class="fc" id="L2826">        Configuration.setBoolean(KEY_CPP_HEADER_GUARD_GUID, addGUID);</span>
<span class="fc" id="L2827">    }</span>

    public int getDefaultInlineStyle() {
<span class="nc" id="L2830">        return Inline.getDefaultStyle();</span>
    }

    public void setDefaultInlineStyle(int inline) {
<span class="nc" id="L2834">        Inline.setDefaultStyle(inline);</span>
<span class="nc" id="L2835">        Configuration.setInteger(KEY_CPP_DEFAULT_INLINE, inline);</span>
<span class="nc" id="L2836">    }</span>
    
    /*
     * Set of already-generated classifiers.
     */
<span class="fc" id="L2841">    private Set generatedFiles = null;</span>
    /*
     * Number of calls to startGenerateFile non closed.
     */
<span class="fc" id="L2845">    private int generateRecur = 0;</span>

    /* implementation of CodeGenerator */
    
    /*
     *  Start generating files. Needed to track dependencies.
     */
    private void startFileGeneration() {
<span class="pc bpc" id="L2853" title="1 of 2 branches missed.">        if (generateRecur++ == 0) {</span>
<span class="fc" id="L2854">            generatedFiles = new HashSet();</span>
        }
<span class="fc" id="L2856">    }</span>
    
    /*
     * End generating files. Needed to track dependencies.
     */
    private void endFileGeneration() {
<span class="pc bpc" id="L2862" title="1 of 2 branches missed.">        if (--generateRecur == 0) {</span>
<span class="fc" id="L2863">            generatedFiles = null;</span>
        }
<span class="fc" id="L2865">    }</span>
    
    /*
     * Generate files for element 'o' (and dependencies, eventually).
     * Return the collection of files (as Strings).
     * Do nothing (and return an empty collection) it 'o' is in generatedFiles.
     */
    private Collection generateFilesForElem(Object o,
                                            String path, boolean deps) {
<span class="fc" id="L2874">        Vector ret = new Vector();</span>
<span class="pc bpc" id="L2875" title="1 of 2 branches missed.">        if (generatedFiles.contains(o)) {</span>
<span class="nc" id="L2876">            return ret; // generated already</span>
        }
<span class="pc bpc" id="L2878" title="3 of 4 branches missed.">        if (!getFacade().isAClass(o) &amp;&amp; !getFacade().isAInterface(o)) {</span>
<span class="nc" id="L2879">            return ret; // not a class or interface</span>
        }
<span class="pc bpc" id="L2881" title="1 of 2 branches missed.">        while (isAInnerClass(o)) {</span>
<span class="nc" id="L2882">            o = getFacade().getNamespace(o);</span>
        }
<span class="fc" id="L2884">        String pathname = null;</span>

        // use unique section for both passes -&gt; allow move of
        // normal function body to inline and vice versa
<span class="pc bpc" id="L2888" title="1 of 2 branches missed.">        if (Section.getUseSect() != Section.SECT_NONE) {</span>
<span class="fc" id="L2889">            sect = new Section();</span>

            /*
             * 2002-11-28 Achim Spangler
             * first read header and source file into global/unique section
             */
<span class="fc" id="L2895">            for (generatorPass = HEADER_PASS;</span>
<span class="fc bfc" id="L2896" title="All 2 branches covered.">                 generatorPass &lt;= SOURCE_PASS;</span>
<span class="fc" id="L2897">                 generatorPass++) {</span>
<span class="fc" id="L2898">                pathname = createDirectoriesPathname(o, path);</span>
                //String pathname = path + filename;
                // TODO: package, project basepath, tagged values to configure
<span class="fc" id="L2901">                File f = new File(pathname);</span>
<span class="fc bfc" id="L2902" title="All 2 branches covered.">                if (f.exists()) {</span>
<span class="fc" id="L2903">                    LOG.info(&quot;Generating (updated) &quot; + f.getPath());</span>
<span class="fc" id="L2904">                    sect.read(pathname);</span>
<span class="fc" id="L2905">                    File bakFile = new File(pathname + &quot;.bak&quot;);</span>
<span class="pc bpc" id="L2906" title="1 of 2 branches missed.">                    if (bakFile.exists()) {</span>
<span class="nc" id="L2907">                        bakFile.delete();</span>
                    }
<span class="fc" id="L2909">                    f.renameTo(bakFile);</span>
<span class="fc" id="L2910">                } else {</span>
<span class="fc" id="L2911">                    LOG.info(&quot;Generating (new) &quot; + f.getPath());</span>
                }
            }
        }

<span class="fc" id="L2916">        Set dependencies = null;</span>
<span class="pc bpc" id="L2917" title="1 of 2 branches missed.">        if (deps) dependencies = new TreeSet();</span>
        /**
         * 2002-11-28 Achim Spangler
         * run basic generation function two times for header and implementation
         */
<span class="fc" id="L2922">        for (generatorPass = HEADER_PASS;</span>
<span class="fc bfc" id="L2923" title="All 2 branches covered.">             generatorPass &lt;= SOURCE_PASS;</span>
<span class="fc" id="L2924">             generatorPass++) {</span>
<span class="fc" id="L2925">            pathname = createDirectoriesPathname(o, path);</span>
<span class="fc" id="L2926">            String fileContent = generateFileAsString(o, pathname);</span>
<span class="pc bpc" id="L2927" title="1 of 2 branches missed.">            if (fileContent.length() == 0) continue;</span>
<span class="fc" id="L2928">            BufferedWriter fos = null;</span>
            //String pathname = path + filename;
            // TODO: package, project basepath, tagged values to configure
<span class="fc" id="L2931">            File f = new File(pathname);</span>
            try {
                // TODO: This is using the default platform character encoding
                // specifying an encoding will produce more predictable results
<span class="fc" id="L2935">                fos = new BufferedWriter (new FileWriter (f));</span>
<span class="fc" id="L2936">                writeTemplate(o, path, fos);</span>
<span class="fc" id="L2937">                fos.write(fileContent);</span>
<span class="fc" id="L2938">                fos.newLine();</span>
            }
<span class="nc" id="L2940">            catch (IOException exp) { }</span>
            finally {
                try {
<span class="pc bpc" id="L2943" title="1 of 2 branches missed.">                    if (fos != null) fos.close();</span>
                }
<span class="nc" id="L2945">                catch (IOException exp) {</span>
<span class="nc" id="L2946">                    LOG.severe(&quot;FAILED: &quot; + f.getPath());</span>
<span class="fc" id="L2947">                }</span>
            }

<span class="fc" id="L2950">            LOG.info(&quot;written: &quot; + pathname);</span>

<span class="pc bpc" id="L2952" title="1 of 2 branches missed.">            if (Section.getUseSect() != Section.SECT_NONE) {</span>
                // output lost sections only in the second path
                // -&gt; sections which are moved from header(inline) to source
                // file are prevented to be outputted in header pass
<span class="fc" id="L2956">                File outFile = new File(pathname + &quot;.out&quot;);</span>
<span class="pc bpc" id="L2957" title="1 of 2 branches missed.">                if (outFile.exists()) {</span>
<span class="nc" id="L2958">                    outFile.delete(); // remove junk</span>
                }
<span class="fc bfc" id="L2960" title="All 2 branches covered.">                if (generatorPass == HEADER_PASS)   {</span>
<span class="fc" id="L2961">                    sect.write(pathname, indent, false);</span>
                } else {
<span class="fc" id="L2963">                    sect.write(pathname, indent, true);</span>
                }

<span class="pc bpc" id="L2966" title="1 of 2 branches missed.">                if (outFile.exists()) {</span>
<span class="pc bpc" id="L2967" title="2 of 4 branches missed.">                    assert f.exists();</span>
<span class="fc" id="L2968">                    f.delete();</span>
<span class="fc" id="L2969">                    outFile.renameTo(f);</span>
<span class="fc" id="L2970">                    LOG.info(&quot;added sections to: &quot; + pathname);</span>
                }
            }
<span class="fc" id="L2973">            LOG.info(&quot;----- end updating &quot; + pathname + &quot;-----&quot;);</span>
<span class="fc" id="L2974">            ret.add(pathname);</span>
<span class="pc bpc" id="L2975" title="1 of 2 branches missed.">            if (deps) {</span>
<span class="nc" id="L2976">                dependencies.add(includeCls);</span>
<span class="nc" id="L2977">                dependencies.add(predeclCls);</span>
            }
        }
<span class="fc" id="L2980">        cleanupGenerator();</span>
        // reset generator pass to NONE for the notation to be correct
<span class="fc" id="L2982">        generatorPass = NONE_PASS;</span>
<span class="fc" id="L2983">        generatedFiles.add(o);</span>
<span class="pc bpc" id="L2984" title="1 of 2 branches missed.">        if (deps) {</span>
<span class="nc" id="L2985">            Iterator it = dependencies.iterator();</span>
<span class="nc bnc" id="L2986" title="All 2 branches missed.">            while (it.hasNext()) {</span>
<span class="nc" id="L2987">                ret.add(generateFilesForElem(it.next(), path, deps));</span>
            }
        }
        
<span class="fc" id="L2991">        return ret;</span>
    }
    
    /*
     * @see org.argouml.uml.generator.CodeGenerator#generate(java.util.Collection, boolean)
     */
    public Collection generate(Collection elements, boolean deps) {
<span class="nc" id="L2998">        List ret = new ArrayList();</span>
<span class="nc" id="L2999">        startFileGeneration();</span>
<span class="nc bnc" id="L3000" title="All 2 branches missed.">        for (Iterator it = elements.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L3001">            Object elem = it.next();</span>
<span class="nc" id="L3002">            String path = generatePath(elem);</span>
<span class="nc" id="L3003">            Set dependencies = null;</span>
<span class="nc bnc" id="L3004" title="All 2 branches missed.">            if (deps) dependencies = new TreeSet();</span>

<span class="nc" id="L3006">            for (generatorPass = HEADER_PASS;</span>
<span class="nc bnc" id="L3007" title="All 2 branches missed.">                 generatorPass &lt;= SOURCE_PASS;</span>
<span class="nc" id="L3008">                 generatorPass++) {</span>
<span class="nc" id="L3009">                String name = getFacade().getName(elem) + getFileExtension();</span>
<span class="nc" id="L3010">                String content = generateFileAsString(elem, path + name);</span>
<span class="nc" id="L3011">                SourceUnit su = new SourceUnit(name, path, content);</span>
<span class="nc" id="L3012">                ret.add(su);</span>
            }
<span class="nc" id="L3014">            generatorPass = NONE_PASS;</span>
<span class="nc" id="L3015">            generatedFiles.add(elem);</span>
<span class="nc bnc" id="L3016" title="All 2 branches missed.">            if (deps) {</span>
<span class="nc" id="L3017">                ret.add(generate(dependencies, deps));</span>
            }
<span class="nc" id="L3019">        }</span>
<span class="nc" id="L3020">        endFileGeneration();</span>
<span class="nc" id="L3021">        return ret;</span>
    }

    /*
     * @see org.argouml.uml.generator.CodeGenerator#generateFiles(java.util.Collection, java.lang.String, boolean)
     */
    public Collection generateFiles(Collection elements, String path,
            boolean deps) {
<span class="fc" id="L3029">        List ret = new ArrayList();</span>
<span class="fc" id="L3030">        startFileGeneration();</span>
<span class="fc bfc" id="L3031" title="All 2 branches covered.">        for (Iterator it = elements.iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L3032">            Object elem = it.next();</span>
<span class="fc" id="L3033">            ret.addAll(generateFilesForElem(elem, path, deps));</span>
<span class="fc" id="L3034">        }</span>
<span class="fc" id="L3035">        endFileGeneration();</span>
<span class="fc" id="L3036">        return ret;</span>
    }

    /*
     * @see org.argouml.uml.generator.CodeGenerator#generateFileList(java.util.Collection, boolean)
     */
    public Collection generateFileList(Collection elements, boolean deps) {
<span class="nc" id="L3043">        List ret = new ArrayList();</span>
<span class="nc" id="L3044">        startFileGeneration();</span>
<span class="nc bnc" id="L3045" title="All 2 branches missed.">        for (Iterator it = elements.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L3046">            Object elem = it.next();</span>
            // FIXME: check for interfaces, inner classes, deps, etc. 
<span class="nc" id="L3048">            ret.add(getFacade().getName(elem) + &quot;.cpp&quot;);</span>
<span class="nc" id="L3049">            ret.add(getFacade().getName(elem) + &quot;.h&quot;);</span>
<span class="nc" id="L3050">        }</span>
<span class="nc" id="L3051">        endFileGeneration();</span>
<span class="nc" id="L3052">        return null;</span>
    }
    
    private static String generateUninterpreted(String un) {
<span class="pc bpc" id="L3056" title="1 of 2 branches missed.">        if (un == null)</span>
<span class="nc" id="L3057">            return &quot;&quot;;</span>
<span class="fc" id="L3058">        return un;</span>
    }

    private static String generateClassifierRef(Object cls) {
<span class="nc bnc" id="L3062" title="All 2 branches missed.">        if (cls == null)</span>
<span class="nc" id="L3063">            return &quot;&quot;;</span>
<span class="nc" id="L3064">        return getFacade().getName(cls);</span>
    }
    
    /**
     * 
     * @param cls object
     * @return String with generated methods
     */
    private String generateInlinedMethodsOutsideClass(Object cls) {
<span class="fc" id="L3073">        String s = new String();</span>
<span class="fc" id="L3074">        Collection op = getFacade().getOperations(cls);</span>
<span class="fc bfc" id="L3075" title="All 2 branches covered.">        if (op.isEmpty()) {</span>
<span class="fc" id="L3076">            return null;</span>
        }

<span class="fc" id="L3079">        s = LINE_SEPARATOR;</span>
<span class="pc bpc" id="L3080" title="1 of 2 branches missed.">        if (verboseDocs) {</span>
<span class="nc" id="L3081">            s += indent + &quot;// Operations&quot; + LINE_SEPARATOR;</span>
        }
        
<span class="fc" id="L3084">        int tmpGeneratorPass = generatorPass;</span>
<span class="fc" id="L3085">        generatorPass = SOURCE_PASS;</span>
        
<span class="fc" id="L3087">        String opString = new String();</span>
<span class="fc" id="L3088">        Iterator opIterator = op.iterator();</span>
<span class="fc bfc" id="L3089" title="All 2 branches covered.">        while (opIterator.hasNext()) {</span>
<span class="fc" id="L3090">            Object bf = opIterator.next();</span>
        
<span class="pc bpc" id="L3092" title="1 of 2 branches missed.">            if (!getFacade().isAbstract(bf)) {</span>
<span class="fc" id="L3093">                Inline inlineStyle = Inline.getInlineOperationModifierType(bf);</span>
<span class="fc bfc" id="L3094" title="All 2 branches covered.">                if (inlineStyle.isMethodBodyOutsideClass()) {</span>
<span class="fc" id="L3095">                    opString += generateOperation(bf, false);</span>
<span class="fc" id="L3096">                    opString += LINE_SEPARATOR + generateMethodBody(bf)</span>
                                + LINE_SEPARATOR;
                }
            }
<span class="fc" id="L3100">        } // end loop through all operations</span>
        
<span class="fc" id="L3102">        generatorPass = tmpGeneratorPass;</span>
        
<span class="fc bfc" id="L3104" title="All 2 branches covered.">        if (opString.length() != 0) {</span>
<span class="fc" id="L3105">            s += opString;</span>
<span class="fc" id="L3106">            return s;</span>
        } else {
<span class="fc" id="L3108">            return null;</span>
        }
    }
    
} /* end class GeneratorCpp */
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>